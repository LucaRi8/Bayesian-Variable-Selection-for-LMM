<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Lo scopo di questo progetto è quello di presentare alcuni tecniche di variable selection in ambito Bayesiano sia da un punto di vista teorico che pratico, mediante un’applicazione reale su dati provenienti dal mondo calcistico.">

<title>Bayesian Variable Selection nel caso di modelli lineari ad effetti fissi e misti</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="BVS_files/libs/clipboard/clipboard.min.js"></script>
<script src="BVS_files/libs/quarto-html/quarto.js"></script>
<script src="BVS_files/libs/quarto-html/popper.min.js"></script>
<script src="BVS_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="BVS_files/libs/quarto-html/anchor.min.js"></script>
<link href="BVS_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="BVS_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="BVS_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="BVS_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="BVS_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Indice</h2>
   
  <ul>
  <li><a href="#introduzione" id="toc-introduzione" class="nav-link active" data-scroll-target="#introduzione">Introduzione</a>
  <ul class="collapse">
  <li><a href="#stima-bayesiana" id="toc-stima-bayesiana" class="nav-link" data-scroll-target="#stima-bayesiana">Stima Bayesiana</a></li>
  <li><a href="#bayes-factors" id="toc-bayes-factors" class="nav-link" data-scroll-target="#bayes-factors">Bayes Factors</a></li>
  <li><a href="#incertezza-del-modello" id="toc-incertezza-del-modello" class="nav-link" data-scroll-target="#incertezza-del-modello">Incertezza del modello</a></li>
  </ul></li>
  <li><a href="#spike-slab-priors-caso-del-modello-di-regressione-lineare" id="toc-spike-slab-priors-caso-del-modello-di-regressione-lineare" class="nav-link" data-scroll-target="#spike-slab-priors-caso-del-modello-di-regressione-lineare">Spike &amp; Slab Priors: caso del modello di regressione lineare</a>
  <ul class="collapse">
  <li><a href="#stochastic-search-mcmc" id="toc-stochastic-search-mcmc" class="nav-link" data-scroll-target="#stochastic-search-mcmc">Stochastic Search MCMC</a></li>
  <li><a href="#spike-slab-priors-for-linear-models-full-conditional-per-gamma" id="toc-spike-slab-priors-for-linear-models-full-conditional-per-gamma" class="nav-link" data-scroll-target="#spike-slab-priors-for-linear-models-full-conditional-per-gamma">Spike &amp; Slab Priors for Linear Models: full conditional per <span class="math inline">\(\gamma\)</span></a></li>
  <li><a href="#spike-slab-priors-for-linear-models-codifica" id="toc-spike-slab-priors-for-linear-models-codifica" class="nav-link" data-scroll-target="#spike-slab-priors-for-linear-models-codifica">Spike &amp; Slab Priors for Linear Models: codifica</a></li>
  </ul></li>
  <li><a href="#spike-slab-priors-per-linear-mixed-models" id="toc-spike-slab-priors-per-linear-mixed-models" class="nav-link" data-scroll-target="#spike-slab-priors-per-linear-mixed-models">Spike &amp; Slab Priors per Linear Mixed Models</a>
  <ul class="collapse">
  <li><a href="#spike-slab-priors-per-linear-mixed-models-codifica" id="toc-spike-slab-priors-per-linear-mixed-models-codifica" class="nav-link" data-scroll-target="#spike-slab-priors-per-linear-mixed-models-codifica">Spike &amp; Slab Priors per Linear Mixed Models: codifica</a></li>
  </ul></li>
  <li><a href="#dataset-football-data-from-transfermarkt" id="toc-dataset-football-data-from-transfermarkt" class="nav-link" data-scroll-target="#dataset-football-data-from-transfermarkt">Dataset: Football Data from Transfermarkt</a>
  <ul class="collapse">
  <li><a href="#analisi-esplorative" id="toc-analisi-esplorative" class="nav-link" data-scroll-target="#analisi-esplorative">Analisi esplorative</a></li>
  <li><a href="#un-semplice-modello-lineare" id="toc-un-semplice-modello-lineare" class="nav-link" data-scroll-target="#un-semplice-modello-lineare">Un semplice modello lineare</a></li>
  <li><a href="#variable-selection-caso-modello-lineare-coniugato" id="toc-variable-selection-caso-modello-lineare-coniugato" class="nav-link" data-scroll-target="#variable-selection-caso-modello-lineare-coniugato">Variable selection: caso modello lineare coniugato</a></li>
  <li><a href="#modello-ad-effetti-misti" id="toc-modello-ad-effetti-misti" class="nav-link" data-scroll-target="#modello-ad-effetti-misti">Modello ad effetti misti</a></li>
  <li><a href="#variable-selection-modello-ad-effetti-misti" id="toc-variable-selection-modello-ad-effetti-misti" class="nav-link" data-scroll-target="#variable-selection-modello-ad-effetti-misti">Variable selection: modello ad effetti misti</a></li>
  </ul></li>
  <li><a href="#bayesian-model-selection-for-generalized-linear-mixed-models" id="toc-bayesian-model-selection-for-generalized-linear-mixed-models" class="nav-link" data-scroll-target="#bayesian-model-selection-for-generalized-linear-mixed-models">Bayesian model selection for generalized linear mixed models</a>
  <ul class="collapse">
  <li><a href="#modello-di-partenza" id="toc-modello-di-partenza" class="nav-link" data-scroll-target="#modello-di-partenza">Modello di partenza</a></li>
  <li><a href="#pseudo-likelihood-function" id="toc-pseudo-likelihood-function" class="nav-link" data-scroll-target="#pseudo-likelihood-function">Pseudo Likelihood function</a></li>
  <li><a href="#model-selection" id="toc-model-selection" class="nav-link" data-scroll-target="#model-selection">Model selection</a></li>
  <li><a href="#prior-for-model-parameters" id="toc-prior-for-model-parameters" class="nav-link" data-scroll-target="#prior-for-model-parameters">Prior for model parameters</a></li>
  <li><a href="#priors-on-the-model-space" id="toc-priors-on-the-model-space" class="nav-link" data-scroll-target="#priors-on-the-model-space">Priors on the model space</a></li>
  <li><a href="#fractional-bayes-factors" id="toc-fractional-bayes-factors" class="nav-link" data-scroll-target="#fractional-bayes-factors">Fractional Bayes factors</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><strong>Bayesian Variable Selection nel caso di modelli lineari ad effetti fissi e misti</strong></h1>
<p class="subtitle lead"><strong>Aspetti teorici e applicazioni pratiche di alcune tecniche di selezione delle variabili in ambito Bayesiano</strong></p>
</div>

<div>
  <div class="description">
    Lo scopo di questo progetto è quello di presentare alcuni tecniche di variable selection in ambito Bayesiano sia da un punto di vista teorico che pratico, mediante un’applicazione reale su dati provenienti dal mondo calcistico.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Autore/Autrice</div>
    <div class="quarto-title-meta-contents">
             <p>Luca Riotto, Marius Viorel Parvu </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Data di Pubblicazione</div>
    <div class="quarto-title-meta-contents">
      <p class="date">2 luglio 2024</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Data di modifica</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">2 luglio 2024</p>
    </div>
  </div>
    
  </div>
  


</header>


<div class="hidden">
<section id="boldsymbols-of-greek-letters" class="level1">
<h1>boldsymbols of greek letters</h1>

</section>
<section id="capital-letters-in-mathbf" class="level1">
<h1>capital letters in mathbf</h1>

</section>
</div>
<section id="introduzione" class="level1">
<h1>Introduzione</h1>
<p>La variable selection (anche detta feature selection) corrisponde al processo di identificazione di un sottoinsieme rilevante di predittori da includere nel modello in esame.</p>
<p>Al fine di perseguire tale obiettivo possiamo identificare due macro-classi di metodi; i metodi basati sulla verifica di ipotesi e quelli che effettuano una stima dei parametri penalizzata. In ambito Bayesiano, nel primo caso si fa ricorso al Bayes factor e alle posterior model probabilties, mentre nel secondo caso vengono specificate delle shrinkage priors che inducono sparsità.</p>
<p>Partiamo dalle basi accennando quanto visto fino ad ora:</p>
<ul>
<li><p>Metodo screening: stimare il modello completo –&gt; calcolare le statistiche T per i parametri –&gt; rimuovere i parametri per i quali le statistiche sono troppo piccole –&gt;ristimare il modello con le variabili restanti;</p></li>
<li><p>Stepwise variable regression: le variabili vengono incluse una per volta partendo dal modello nullo (Forward Selection), oppure vengono eliminate una alla volta partendo dal modello completo (Backward Elimination), oppure una combinazione delle due precedenti.</p></li>
</ul>
<p>Per una rassegna delle tecniche di base, si veda <span class="citation" data-cites="miller2002subset">Miller (<a href="#ref-miller2002subset" role="doc-biblioref">2002</a>)</span>.</p>
<p>Quello che hanno in comune questi metodi è il fatto che scelgono un modello tra i diversi possibili e poi procedono come se quello fosse l’unico. Questo, però, può portare a dei risultati fuorvianti. Questo perchè, scegliendo un solo modello tra tanti, aumenta la probabilità di trovare variabili significative per puro caso. Per comprendere meglio la problematica si consideri l’esempio proposto da <span class="citation" data-cites="freedman1983note">Freedman (<a href="#ref-freedman1983note" role="doc-biblioref">1983</a>)</span>: si supponga di disporre di una matrice formata da 100 righe (le unità statistiche) e 51 colonne (le v.c. che, per costruzione, sono indipendenti tra loro). Scegliamo, in modo arbitrario, di attribuire alla 51-ma variabile il ruolo di variabile dipendente <span class="math inline">\(Y\)</span>, mentre alle altre il ruolo di variabili dipendenti <span class="math inline">\(X_1, X_2,...X_{50}\)</span>. Per costruzione, ci aspetteremmo di avere un <span class="math inline">\(R^2\)</span> molto basso e dei coefficienti non significativi. Cosa succede nella realtà: se regrediamo <span class="math inline">\(Y\)</span> su <span class="math inline">\(X_1, X_2,...X_{50}\)</span> otteniamo un <span class="math inline">\(R^2 = 0.60\)</span> e 21 coefficienti significativi a livello 0.25. La regressione è stata rifatta su queste 21 variabili, ottenendo un <span class="math inline">\(R^2 = 0.50\)</span> e 20 coefficienti significativi a livello 0.25 (14 dei quali significativi al livello 0.05). L’esempio porta alla luce dei risultati fuorvianti: sembrerebbe che ci sia una relazione tra la risposta e le esplicative. Un risultato simile si sarebbe ottenuto applicando la stepwise regressione: in questo caso si otterrebbe un <span class="math inline">\(R^2=0.18\)</span> e 4 coefficienti significativi al livello <span class="math inline">\(0.05\)</span>. Una soluzione a questo problema arriva dal mondo Bayesiano: grazie a questo approccio, infatti, si potrebbe tenere in considerazione, in modo esplicito, l’incertezza del modello.</p>
<section id="stima-bayesiana" class="level2">
<h2 class="anchored" data-anchor-id="stima-bayesiana">Stima Bayesiana</h2>
<p>Come sappiamo, il mondo Bayesiano esprime tutta l’incertezza (inclusa quella relativa ai parametri ignoti del modello) in termini di probabilità e i parametri ignoti vengono considerati, a loro volta, come delle variabili casuali.</p>
<p>Si consideri di avere a disposizione un insieme di dati <span class="math inline">\(D\)</span>, caratterizzato da un insieme di <span class="math inline">\(d\)</span> parametri <span class="math inline">\(\theta = (\theta_1, \ldots, \theta_d)\)</span>. Sia:</p>
<ul>
<li><p><span class="math inline">\(p(\theta)\)</span> la prior, ovvero la quantità che rappresenta la nostra conoscenza di <span class="math inline">\(\theta\)</span> prima di aver osservato i dati;</p></li>
<li><p><span class="math inline">\(p(D \mid \theta)\)</span> la verosimiglianza dei dati, ovvero la probabilità di osservare <span class="math inline">\(D\)</span> dato che <span class="math inline">\(\theta\)</span> è il vero valore dei parametri;</p></li>
<li><p><span class="math inline">\(p(\theta \mid D) = \frac{p(D \mid \theta) p(\theta)}{p(D)} \propto p(D \mid \theta) p(\theta)\)</span> la posterior, ovvero l’aggiornamento delle nostre conoscenze su <span class="math inline">\(\theta\)</span> dopo aver osservato i dati. <span class="math inline">\(p(\theta \mid D)\)</span> contiene tutta l’informazione necessaria per fare inferenza su <span class="math inline">\(\theta\)</span>, basta solo decidere come riassumerla e comunicarla (es, utilizzando la moda).</p></li>
</ul>
</section>
<section id="bayes-factors" class="level2">
<h2 class="anchored" data-anchor-id="bayes-factors">Bayes Factors</h2>
<p>Supponiamo di voler utilizzare i dati <span class="math inline">\(D\)</span> per comparare due ipotesi, rappresentate dai modelli <span class="math inline">\(M_1\)</span>, con parametri <span class="math inline">\(\theta_1\)</span>, e <span class="math inline">\(M_2\)</span>, con parametri <span class="math inline">\(\theta_2\)</span>. Per il teorema di Bayes, la probabilità a posteriori che <span class="math inline">\(M_1\)</span> sia il modello corretto è</p>
<p><span class="math display">\[
p(M_1 \mid D) = \frac{p(D \mid M_1)p(M_1)}{p(D \mid M_1)p(M_1) +p(D \mid M_2)p(M_2)}
\]</span> dove <span class="math inline">\(p(D \mid M_k)\)</span>, chiamata verosimiglianza integrata per il modello <span class="math inline">\(M_k\)</span>, è la probabilità dei dati dato il modello <span class="math inline">\(M_k\)</span>, mentre <span class="math inline">\(p(M_k)\)</span> è la probabilità a priori del modello <span class="math inline">\(M_k (k=1,2)\)</span>. <span class="math inline">\(p(D \mid M_1)\)</span> si ottiene integrando <span class="math inline">\(\theta_1\)</span>, ovvero <span class="math inline">\(p(D \mid M_1)= \int p(D \mid \theta_1, M_1)p(\theta_1 \mid M_1) d\theta_1\)</span>, dove <span class="math inline">\(p(D \mid \theta_1, M_1)\)</span> è la verosimiglianza per <span class="math inline">\(\theta_1\)</span> sotto il modello <span class="math inline">\(M_1\)</span>. Per misurare quanto i dati supportino <span class="math inline">\(M_2\)</span> rispetto a <span class="math inline">\(M_1\)</span> si calcola il rapporto delle probabilità a posteriori: <span class="math display">\[
\frac{p(M_2 \mid D)}{p(M_1 \mid D)}= \left[ \frac{p(D \mid M_2)}{p(D \mid M_1)} \right] \left[  \frac{p(M_2)}{p(M_1)}\right]
\]</span> Il primo fattore sul lato destro corrisponde al rapporto delle verosimiglianze integrate dei due modelli (Bayes factor per <span class="math inline">\(M_2\)</span> contro <span class="math inline">\(M_1\)</span>, <span class="math inline">\(B_{21}\)</span>); il secondo è il rapporto delle prior e molto spesso corrisponde a 1 per rappresentare l’assenza di preferenza (a priori) per uno dei due modelli. Seguendo le regole empirirche proposte da <span class="citation" data-cites="jeffreys1998theory">Jeffreys (<a href="#ref-jeffreys1998theory" role="doc-biblioref">1998</a>)</span>:</p>
<table class="table">
<thead>
<tr class="header">
<th>Condizione</th>
<th>Esito</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(1 \leq B_{21} &lt; 3\)</span></td>
<td>evidenza molto debole per <span class="math inline">\(M_2\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(3 \leq B_{21} &lt; 10\)</span></td>
<td>evidenza positiva per <span class="math inline">\(M_2\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(10 \leq B_{21} &lt; 100\)</span></td>
<td>evidenza forte per <span class="math inline">\(M_2\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(B_{21} \geq 100\)</span></td>
<td>evidenza molto forte per <span class="math inline">\(M_2\)</span></td>
</tr>
</tbody>
</table>
<p>Utilizzare il Bayes factor richiede di calcolare integrali, che a volte possono essere intrattabili. Per questa ragione si sfruttano approssimazioni numeriche, come la BIC approximation. Per esempio, nel caso in cui <span class="math inline">\(M_1\)</span> sia nested dentro <span class="math inline">\(M_2\)</span> si ha che: <span class="math display">\[
2log(B_{21}) \approx \chi^{2}_{21} - df_{21}log(n)
\]</span> dove <span class="math inline">\(\chi^{2}_{21}\)</span> è la statistica LRT per <span class="math inline">\(M_1\)</span> contro <span class="math inline">\(M_2\)</span> e <span class="math inline">\(df_{21}=d_2-d_1\)</span> sono i gradi di libertà associati al test.</p>
<p>Quando vengono considerati diversi modelli è utile compare ciascuno di loro con un modello baseline, come ad esempio il modello saturo. Nel caso del modello baseline saturo (<span class="math inline">\(M_S\)</span>), il valore del BIC per il modello <span class="math inline">\(M_k\)</span>, chiamato <span class="math inline">\(BIC_k\)</span> è l’approssimazione di <span class="math inline">\(2log(B_{Sk})\)</span>. Proseguendo, <span class="math inline">\(BIC_S\)</span>, ovvero il BIC per il modello saturo, sarà zero, quindi il modello saturo sarà da preferire se <span class="math inline">\(BIC_k &gt;0\)</span>. Quando compariamo due modelli, <span class="math inline">\(M_j\)</span> e <span class="math inline">\(M_k\)</span> si nota che: <span class="math display">\[
2logB_{jk}= 2logB_{Sk} - 2logB_{Sj} \approx BIC_k - BIC_j.
\]</span> Si preferisce il modello con valore di BIC più piccolo.</p>
</section>
<section id="incertezza-del-modello" class="level2">
<h2 class="anchored" data-anchor-id="incertezza-del-modello">Incertezza del modello</h2>
<p>Passiamo ora dal cosiderare due soli modelli al considerarne molti: <span class="math inline">\(M_1, M_2,...;M_K\)</span>. Sia <span class="math inline">\(\Delta\)</span> un parametro di interesse. L’inferenza Bayesiana per <span class="math inline">\(\Delta\)</span> si basa sulla sua posterior, ovvero: <span class="math display">\[
p(\Delta \mid D) = \sum_{k=1}^{K} p(\Delta \mid D, M_k)p(M_k \mid D)
\]</span> Quindi la distribuzione a posteriori per <span class="math inline">\(\Delta\)</span> è una media pesata delle sue posterior distributions sotto ciascun modello, con pesi pari alle posterior model probabilities (<span class="math inline">\(p(M_k \mid D)\)</span>). In questo modo consideriamo anche l’incertezza del modello. Per individuare un sottoinsieme di k modelli da considerare, si possono applicare delle regole euristiche (es, Occam’s window). Per ottenere le posterior model probabilities si procede nel seguente modo: <span class="math display">\[
p(M_k \mid D) = \frac{p(D \mid M_k)p(M_k)}{\sum_{l=1}^{K} p( D \mid M_l)p(M_l)}
\]</span> Spesso tutti i modelli hanno a priori pari probabilità, quindi, <span class="math inline">\(p(M_1)=...=p(M_k)=1/K\)</span>. Nel caso in cui volessimo vedere se un coefficiente è incluso nel modello dovremmo calcolare: <span class="math display">\[
P(\beta_1 \neq 0 \mid D)= \sum_{A_1}p(M_k \mid D)
\]</span> dove <span class="math inline">\(A_1\)</span> è l’insieme dei modelli che includono <span class="math inline">\(\beta_1\)</span>.</p>
<p>Per concludere, tornando all’esempio di <span class="citation" data-cites="freedman1983note">Freedman (<a href="#ref-freedman1983note" role="doc-biblioref">1983</a>)</span>: applicando la metodologia appena descritta, si identificano 5 modelli (tra cui anche il modello nullo). Poi, calcolando <span class="math inline">\(P(\beta_j \neq 0 \mid D)\)</span> si scopre che 44 variabili vengono poste pari a zero, mentre le restanti 5 presentano una evidenza molto debole.</p>
<p>Per ulteriori approfondimenti su questa metodologia, si veda <span class="citation" data-cites="raftery1995bayesian">Raftery (<a href="#ref-raftery1995bayesian" role="doc-biblioref">1995</a>)</span>.</p>
<p>Abbiamo voluto portare l’esempio di questo articolo per far comprendere le potenzialità dell’adottare l’approccio Bayesiano alla selezione delle variabili. Passiamo, ora, a vedere una metodologia comunemente usata per la Bayesian variable selection: le Spiake &amp; Slab prior.</p>
</section>
</section>
<section id="spike-slab-priors-caso-del-modello-di-regressione-lineare" class="level1">
<h1>Spike &amp; Slab Priors: caso del modello di regressione lineare</h1>
<p>Si supponga di avere a disposizione una risposta continua, <span class="math inline">\(y_i\)</span>, modellata mediante una combinazione lineare delle <span class="math inline">\(p\)</span> covariate, <span class="math inline">\(x_i = (x_1,...,x_p) \in \mathbb{R}^p\)</span> , nel seguente modo: <span class="math display">\[
y_i = \alpha + x_i^T\beta + \epsilon_i, \quad i=1,...,n \\
\epsilon_i \sim N(0, \sigma^2), \quad \beta=(\beta_1,..., \beta_p)^T
\]</span> Come sappiamo, il problema della variable selection nasce quando si presume che non tutte le p covariate siano importanti per spiegare la risposta. Chiaramente, porre pari a zero alcuni parametri equivale a eslcludere le corrispondenti variabili dal modello. Nel paradigma Bayesiano, questo può essere raggiunto utilizzando misture di priori (come, per esempio, le spike &amp; slab) per i coefficienti <span class="math inline">\(\beta\)</span>. Tale formulazione introduce un vettore latente <span class="math inline">\(\gamma=(\gamma_1,...,\gamma_p)\)</span> di indicatrici, dove <span class="math display">\[
\gamma_j=\left\{
\begin{array}{ll}
1 \quad \text{se la variabile j viene inclusa nel modello} \\
0 \quad \text{altrimenti}
\end{array}
\right.
\]</span> La letteratura ha sviluppato, in parallelo, due costruzioni delle spike-and-slab: una costruzione discreta e una continua. La costruzione discreta utilizza una mistura tra una funzione di Dirac e una distribuzione (ad es una normale): <span class="math display">\[
\beta_j \mid \sigma^2, \gamma_j \sim(1-\gamma_j)\delta_0(\beta_j) + \gamma_jN(0,h_j\sigma^2) \quad j=1,...,p
\]</span> dove <span class="math inline">\(\delta_0()\)</span> rappresenta la funzione di Dirac in <span class="math inline">\(\beta_j=0\)</span> e <span class="math inline">\(h_j\)</span> un insieme di iper-parametri. Qui, <span class="math inline">\(\gamma_j=0\)</span> esclude la <span class="math inline">\(j\)</span>-esima variabile dal modello, mentre <span class="math inline">\(\gamma_j=1\)</span> include il predittore nel modello, portando a una prior normale per <span class="math inline">\(\beta_j\)</span>. Concludiamo la formulazione assumendo che: <span class="math display">\[
\alpha \mid\sigma^2 \sim N(\alpha_0, h_0\sigma^2), \quad \sigma^2 \sim IG(\nu/2, \lambda/2),
\]</span> dove <span class="math inline">\(\alpha_0, h_0, \nu, \lambda\)</span> sono iperparametri da scegliere. Per esempio, ponendo <span class="math inline">\(\alpha_0=0\)</span> e prendendo un <span class="math inline">\(h_0\)</span> molto grande, si ottiene una a priori non informativa per l’intercetta. Proseguendo, è uso comune porre <span class="math inline">\(h_j=c \quad \forall j\)</span>, assumendo così che i <span class="math inline">\(\beta_j\)</span> siano a priori indipendenti dato <span class="math inline">\(\gamma\)</span>.</p>
<p>La costruzione presentata richiede la scelta di una prior anche per <span class="math inline">\(\gamma\)</span>. La scelta più semplice è considerare il prodotto di bernoulli indipendenti con parametro comune <span class="math inline">\(w\)</span>: <span class="math display">\[
p(\gamma \mid w)= \prod_{j=1}^{p}w^{\gamma_j}(1-w)^{1-\gamma_j}\\
w \sim Beta(a,b)
\]</span> Per una a priori poco informativa si imposta a=b=1, quindi il valore atteso a priori risulta essere <span class="math inline">\(m=a/(a+b)=0.5\)</span> N.B.: <span class="math inline">\(pw\)</span> corrisponde al numero di variabili attese che, a priori, si pensa vengano incluse nel modello.</p>
<p>La costruzione discreta presentata poc’anzi differisce poco da quella continua, la quale utilizza una mistura di due componenti continue (solitamente due gaussiane), una centrata in zero e con poca varianza, l’altra invece molto diffusa. Di seguito viene riportato un esempio di Spike &amp; Slab continua e discreta:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="spike_slab_continua_discreta_confronto.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<section id="stochastic-search-mcmc" class="level2">
<h2 class="anchored" data-anchor-id="stochastic-search-mcmc">Stochastic Search MCMC</h2>
<p>Consideriamo il modello lineare, di cui abbiamo parlato precedentemente, assieme alla prior Spike &amp; Slab. La scelta di a priori coniugate rende possibile integrare via i parametri del modello e ottenere la relative posterior distribution per <span class="math inline">\(\gamma\)</span>: <span class="math display">\[
p(\gamma \mid y, X) \propto f(y \mid \gamma, X)p(\gamma)
\]</span> Questa distribuzione permette di individuare i migliori modelli, ovvero quelli con le più alte probabilità a posteriori. Quando il numero di predittori non permette di esplorare completamente lo spazio dei modelli, i metodi MCMC possono essere usati come stochastic searches per esplorare le distribuzioni a posteriori e identificare i modelli con le più alte probabilità a posteriori. Il metodo consiste nel visitare una serie di modelli dove, ad ogni step, il nuovo modello visitato differisce dal precedente per l’inclusione e/o l’esclusione di una o due variabili. Più nello specifico, dato un valore casuale di input, <span class="math inline">\(\gamma_0\)</span>, a una generica iterazione il nuovo modello viene generato dal precedente scegliendo casualmente tra una delle seguenti:</p>
<ol type="1">
<li>Adding or deleting: scegliere casualmente un elemento di <span class="math inline">\(\gamma^{\text{old}}\)</span> e cambiare il suo valore. Questo porta a includere una nuova variabile nel modello, oppure a eliminarla;</li>
<li>Swapping: estrarre in modo indipendente e casuale uno 0 e un 1 da <span class="math inline">\(\gamma^{\text{old}}\)</span> e scambiare i loro valori. Questo porta all’inclusione di una nuova variabile nel modello e all’esclusione di una già presente. Indicando, ora, come <span class="math inline">\(\gamma^{\text{new}}\)</span> il modello candidato, la probabilità di accettazione si calcola come: <span class="math display">\[
min \left[ \frac{p(\gamma^{\text{new}} \mid y,X)}{p(\gamma^{\text{old}} \mid y, X)}, 1\right]
\]</span> Quindi, se il nuovo modello candidato ha una probabilità più alta del modello corrente, allora la catena si muove verso la nuova configurazione. Se così non è, allora il movimento è ancora possibile, ma solo con una certa probabilità. La stochastic search consiste, quindi, in una lista di modelli ispezionati, <span class="math inline">\(\gamma^{(0)}, ..., \gamma^{(T)}\)</span>, e nelle loro relative posterior probabilities. Possiamo, poi, fare selezione delle variabili o cercando i vettori <span class="math inline">\(\gamma\)</span> con le più grandi joint posterior probabilities tra i modelli visitati, oppure calcolando le frequenze di inclusione per ogni <span class="math inline">\(\gamma_j\)</span> e poi scegliendo quei <span class="math inline">\(\gamma_j\)</span> con le frequenze che eccedono un certo cut-off (solitamente pari a 0.5).</li>
</ol>
<p>Per ulteriori approfondimenti, si veda <span class="citation" data-cites="tadesse2021handbook">Tadesse e Vannucci (<a href="#ref-tadesse2021handbook" role="doc-biblioref">2021</a>)</span>.</p>
</section>
<section id="spike-slab-priors-for-linear-models-full-conditional-per-gamma" class="level2">
<h2 class="anchored" data-anchor-id="spike-slab-priors-for-linear-models-full-conditional-per-gamma">Spike &amp; Slab Priors for Linear Models: full conditional per <span class="math inline">\(\gamma\)</span></h2>
<p>Modello di partenza: <span class="math display">\[
\begin{split}
&amp;Y|\beta_\gamma,\sigma^2_\epsilon, \gamma \:\:\:\: \sim \: N(X_\gamma\beta_\gamma,\: \sigma^2_\epsilon I_n ) \\[1.1ex]
&amp;\text{dove}\\[1.1ex]
&amp;\beta_\gamma|\sigma^2_\epsilon, \gamma \:\:\:\: \sim \: N_{p_\gamma}(0, \: \sigma^2_\epsilon D_{0\gamma})\\[1.1ex]
&amp;\gamma=\left[\gamma_1,\: ...,\: \gamma_p\right]^T \:\:\:\text{con}\:\:\:
\gamma_i=\begin{cases}
1 &amp; \text{se $i$-esima variabile è nel modello}\\
0 &amp; \text{altrimenti}
\end{cases}\\[1.1ex]
&amp;\gamma_i \:\:\:\: \sim \: Be(\theta)\:\:\: \text{e}\:\:\: p_\gamma=\sum_{i=1}^{p}\gamma_i \:\:\:\: \sim \: Binom(p, \theta)
\end{split}
\]</span></p>
<p>La distribuzione congiunta a posteriori è:</p>
<p><span class="math display">\[
\begin{split}
p(\beta_\gamma, \sigma^2_\epsilon, \gamma, y | X) \:\:\: \propto \:\:&amp;
(\sigma^2_\epsilon)^{-n/2}exp\left\{-\frac{1}{2\sigma^2_\epsilon}(Y-X_\gamma\beta_\gamma )^T(Y-X_\gamma\beta_\gamma)\right\}\\[1.1ex]
&amp;\times \:|\sigma^2_\epsilon \,D_{0\gamma}|^{-1/2}\, exp\left\{ -\frac{1}{2\sigma^2_\epsilon} \beta^T_\gamma D_{0\gamma}^{-1} \beta_\gamma \right\}\\[1.1ex]
&amp;\times \: (\sigma^2_\epsilon)^{-\nu_\epsilon-1}\,exp\left\{-\frac{\lambda_\epsilon}{\sigma^2_\epsilon}\right\}  \times \theta^{p_\gamma} (1-\theta)^{(p-p_\gamma)}\\[1.1ex]
\end{split}
\]</span></p>
<p>Otteniamo la marginale per <span class="math inline">\(\gamma\)</span> integrando <span class="math inline">\(\beta_\gamma\)</span> e <span class="math inline">\(\sigma^2_\epsilon\)</span>: <span class="math display">\[
\begin{align}
&amp;\int \int  p(\beta_\gamma, \sigma^2_\epsilon, \gamma, y | X)\, d\beta_\gamma \, d\sigma^2_\epsilon\notag\\[1.1ex]
=&amp;\int \int (\sigma^2_\epsilon)^{-\frac{n}{2}-\frac{p_\gamma}{2}} |D_{0\gamma}|^{-\frac{1}{2}} exp \left\{-\frac{y^Ty}{2\sigma^2_\epsilon} + \frac{y^TX_\gamma\beta_\gamma}{\sigma^2_\epsilon} - \frac{\beta_\gamma^T X_\gamma^T X_\gamma \beta_\gamma}{2\sigma^2_\epsilon} -\frac{\beta_\gamma^T D_{0\gamma}^{-1}\beta_\gamma}{2\sigma^2_\epsilon} \right\}\notag\\[1.1ex]
&amp; \quad \:\:\: \times \:\: \left(\frac{1}{\sigma^2_\epsilon} \right)^{\nu_\epsilon + 1}exp\left\{-\frac{\lambda_\epsilon}{\sigma^2_\epsilon}\right\} \, d\beta_\gamma \, d\sigma^2_\epsilon \notag\\[1.1ex]
=&amp;\int \int (\sigma^2_\epsilon)^{-\frac{n}{2} - \frac{p_\gamma}{2} - \nu_\epsilon -1} |D_{0\gamma}|^{-\frac{1}{2}} exp \left\{ -\frac{y^Ty}{2\sigma^2_\epsilon}\right\} exp \left\{ \frac{y^TX_\gamma \beta_\gamma}{\sigma^2_\epsilon} - \frac{\beta_\gamma^T(X_\gamma^TX_\gamma + D_{0\gamma}^{-1})\beta_\gamma}{2\sigma^2_\epsilon} \right\} \notag\\[1.1ex]
&amp; \quad \:\:\: \times \:\:exp\left\{-\frac{\lambda_\epsilon}{\sigma^2_\epsilon}\right\} \, d\beta_\gamma \, d\sigma^2_\epsilon \notag\\[1.1ex]
&amp;\:\:\: \propto \:\:\int (\sigma^2_\epsilon)^{-\frac{n}{2} - \frac{p_\gamma}{2} - \nu_\epsilon -1} |D_{0\gamma}|^{-\frac{1}{2}}exp \left\{ -\frac{y^Ty}{2\sigma^2_\epsilon}\right\} |\sigma^2_\epsilon(X_\gamma^T X_\gamma + D_{0\gamma})^{-1}|^{\frac{1}{2}} \notag\\[1.1ex]
&amp;\quad \:\:\: \times \:\:exp \left\{-\frac{1}{2\sigma^2_\epsilon} (X_\gamma^T X_\gamma + D_{0_\gamma}^{-1}) y^T X_\gamma (X_\gamma^T X_\gamma + D_{0_\gamma}^{-1})^{-2} X_\gamma^T y\right\}  \, d\sigma^2_\epsilon \notag\\[1.1ex]
&amp;\:\:\: \propto \:\:\int (\sigma^2_\epsilon)^{-\frac{n}{2} - \frac{p_\gamma}{2} - \nu_\epsilon -1} (\sigma^2_\epsilon)^{\frac{p_\gamma}{2}} \, |(X_\gamma^T X_\gamma + D_{0\gamma})^{-1}|^{\frac{1}{2}} \,|D_{0\gamma}|^{-\frac{1}{2}} \notag\\[1.1ex]
&amp;\quad \:\:\: \times \:\:exp \left\{ -\frac{1}{\sigma^2_\epsilon} \left[ \frac{y^T y}{2} + \lambda_\epsilon - \frac{y^T X_\gamma (X_\gamma^T X_\gamma + D_{0\gamma}^{-1})^{-1}X^T_\gamma y}{2}    \right] \right\} \, d\sigma^2_\epsilon \notag\\[1.1ex]
&amp;\:\:\: \propto \:\: | (X_\gamma^T X_\gamma + D_{0\gamma}^{-1} ) ^{-1}|^{\frac{1}{2}} \, \,|D_{0\gamma}|^{-\frac{1}{2}} \, \,\frac{\Gamma(n/2 + \nu_\epsilon)}{\left(\lambda_\epsilon + \frac{y^T y}{2} -  \frac{y^T X_\gamma (X_\gamma^T X_\gamma + D_{0\gamma}^{-1})^{-1} X_\gamma y}{2}\right)^{n/2 + \nu_\epsilon}}
\end{align}
\]</span> Quindi: <span class="math display">\[
p(\gamma|y, X)\:\:\: \propto \:\: | (X_\gamma^T X_\gamma + D_{0\gamma}^{-1} ) ^{-1}|^{\frac{1}{2}} \, \,|D_{0\gamma}|^{-\frac{1}{2}} \, \,\left(\lambda_\epsilon + \frac{y^T y}{2} -  \frac{y^T X_\gamma (X_\gamma^T X_\gamma + D_{0\gamma}^{-1})^{-1} X_\gamma y}{2}\right)^{n/2 + \nu_\epsilon}  \\[1.1ex]
\times \theta^{p_\gamma}(1-\theta)^{(p-p_\gamma)}
\]</span></p>
</section>
<section id="spike-slab-priors-for-linear-models-codifica" class="level2">
<h2 class="anchored" data-anchor-id="spike-slab-priors-for-linear-models-codifica">Spike &amp; Slab Priors for Linear Models: codifica</h2>
<p>Per poter ispezionare la posterior di <span class="math inline">\(\gamma\)</span> si è fatto uso di un algoritmo di tipo Reversible-Jump (segue lo stesso schema di un Metropolis). Di seguito viene riportato il codice:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># compute the marginal likelihood of gamma given y and X</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>m_like <span class="ot">&lt;-</span> <span class="cf">function</span>(gamma, y, modelMAT, theta, lambda, ni, v, pos_list, n, p) {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># v parameter of the prior variance (in D0)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># n and p are sample size and number of parameter</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># assume prior beta0 = 0 e D0 = diag(p)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># the intercept is always included</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">colnames</span>(modelMAT)[<span class="dv">1</span>] <span class="sc">==</span> <span class="st">"(Intercept)"</span> )</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    pos_gamma <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="fu">which</span>(gamma <span class="sc">==</span> <span class="dv">1</span>)<span class="sc">+</span><span class="dv">1</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> pos_gamma <span class="ot">&lt;-</span> <span class="fu">which</span>(gamma <span class="sc">==</span> <span class="dv">1</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  pos_in_data <span class="ot">&lt;-</span> <span class="fu">do.call</span>(c, <span class="fu">lapply</span>(pos_gamma, <span class="cf">function</span>(i) pos_list[[i]]))</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  X <span class="ot">&lt;-</span> <span class="fu">Matrix</span>(modelMAT[, pos_in_data])</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  D0 <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="fu">ncol</span>(X)) <span class="sc">*</span> v</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  yty <span class="ot">&lt;-</span> <span class="fu">crossprod</span>(y)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  XtX <span class="ot">&lt;-</span> <span class="fu">crossprod</span>(X) <span class="sc">+</span> <span class="fu">diag</span>(<span class="fu">rep</span>(<span class="dv">1</span><span class="sc">/</span>v, <span class="fu">ncol</span>(X)))</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  XtX_inv <span class="ot">&lt;-</span><span class="fu">chol2inv</span>(<span class="fu">chol</span>(XtX))</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  S <span class="ot">&lt;-</span> yty <span class="sc">-</span>  <span class="fu">crossprod</span>(y, X) <span class="sc">%*%</span> XtX_inv <span class="sc">%*%</span> <span class="fu">t</span>(<span class="fu">crossprod</span>(y, X))</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  gamma_post <span class="ot">&lt;-</span> <span class="fl">0.5</span><span class="sc">*</span> <span class="fu">determinant</span>(XtX_inv, <span class="at">logarithm =</span> T)<span class="sc">$</span>modulus <span class="sc">-</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    (n<span class="sc">/</span><span class="dv">2</span> <span class="sc">+</span> ni) <span class="sc">*</span> <span class="fu">log</span>(lambda <span class="sc">+</span> S<span class="sc">/</span><span class="dv">2</span>) <span class="sc">-</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span><span class="sc">/</span><span class="dv">2</span>)<span class="sc">*</span><span class="fu">log</span>(v<span class="sc">**</span><span class="fu">sum</span>(gamma)) <span class="sc">+</span> <span class="fu">dbinom</span>(<span class="fu">sum</span>(gamma), <span class="at">size =</span> p, <span class="at">prob =</span> theta, <span class="at">log =</span> T)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(gamma_post)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co"># RJ MCMC function</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>RJ_MCMC <span class="ot">&lt;-</span> <span class="cf">function</span>(R, y, data, lambda, ni, <span class="at">theta =</span> <span class="fl">0.5</span>, gamma_init, <span class="at">v =</span> <span class="dv">1</span>, pos_list, verbose) {</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>  <span class="co"># lambda, ni iperparameter for sigma</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>  <span class="co"># zeta, phi iperparameter for theta</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># theta prob for gamma distribution</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(data)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>  p <span class="ot">&lt;-</span> <span class="fu">length</span>(gamma_init)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>  gamma_sim <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, R<span class="sc">+</span><span class="dv">1</span>, <span class="fu">length</span>(gamma_init)) <span class="co"># store simulated value</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>  m_sim <span class="ot">&lt;-</span> <span class="fu">numeric</span>(R<span class="sc">+</span><span class="dv">1</span>) <span class="co"># store m(gamma| X, y)</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>  <span class="co"># init marginal likelihood</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>  m_0 <span class="ot">&lt;-</span> <span class="fu">m_like</span>(gamma_init, y, data, theta, lambda, ni, v, pos_list, n, p)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>  <span class="co"># store the inizialisation parameter</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>  gamma_sim[<span class="dv">1</span>, ] <span class="ot">&lt;-</span> gamma_init</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>  m_sim[<span class="dv">1</span>] <span class="ot">&lt;-</span> m_0</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>  gamma0 <span class="ot">&lt;-</span> gamma_init </span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>R){</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    gamma1 <span class="ot">&lt;-</span> gamma0</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    pos <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>p, <span class="at">size =</span> <span class="dv">1</span>)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ifelse</span>(gamma1[pos]<span class="sc">==</span><span class="dv">0</span>, gamma1[pos] <span class="ot">&lt;-</span> <span class="dv">1</span>, gamma1[pos] <span class="ot">&lt;-</span> <span class="dv">0</span>)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    m_1 <span class="ot">&lt;-</span> <span class="fu">m_like</span>(gamma1, y, data, theta, lambda, ni, v, pos_list, n, p)</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    alpha <span class="ot">&lt;-</span> <span class="fu">exp</span>(m_1 <span class="sc">-</span> m_0)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">as.numeric</span>(<span class="fu">runif</span>(<span class="dv">1</span>) <span class="sc">&lt;</span> alpha))</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>      gamma0 <span class="ot">&lt;-</span> gamma1</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>      m_0 <span class="ot">&lt;-</span> m_1</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    gamma_sim[i<span class="sc">+</span><span class="dv">1</span>, ] <span class="ot">&lt;-</span> gamma0</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    m_sim[i<span class="sc">+</span><span class="dv">1</span>] <span class="ot">&lt;-</span> m_0</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(verbose <span class="sc">==</span> T) {</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(i <span class="sc">%%</span> <span class="dv">100</span> <span class="sc">==</span> <span class="dv">0</span>) <span class="fu">print</span>(i)</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">gamma =</span> gamma_sim, <span class="at">lm =</span> m_sim))</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="spike-slab-priors-per-linear-mixed-models" class="level1">
<h1>Spike &amp; Slab Priors per Linear Mixed Models</h1>
<p>Fino ad ora ci si è concentrati sulla selezione delle variabili per i modelli lineari. Nel caso di modelli ad effetti misti si fa ricorso a uno schema gibbs, dove, ad ogni iterazione, i parametri vengono generati dalle distribuzioni condizionate che verranno presentate nel seguito.</p>
<p>Modello di partenza: <span class="math display">\[
\begin{split}
&amp;Y|\beta_\gamma,u,\sigma^2_\epsilon,\sigma^2_u, \gamma \:\:\:\: \sim \: N(X_\gamma\beta_\gamma + Zu,\: \sigma^2_\epsilon I_n ) \\[1.1ex]
&amp;\text{dove}\\[1.1ex]
&amp;\beta_\gamma|\sigma^2_\epsilon, \gamma \:\:\:\: \sim \: N_{p_\gamma}(0, \: \sigma^2_\epsilon D_{0\gamma})\\[1.1ex]
%
&amp;\sigma^2_\epsilon \:\:\:\: \sim \: IG(\nu_\epsilon, \: \lambda_\epsilon)\\[1.1ex]
%
&amp;u \:\:\:\: \sim \: N_k(0,\: \sigma^2_u I_k)\\[1.1ex]
%
&amp;\sigma^2_u \:\:\:\: \sim \: IG(\nu_u, \: \lambda_u)\\[1.1ex]
%
&amp;\gamma=\left[\gamma_1,\: ...,\: \gamma_p\right]^T \:\:\:\text{con}\:\:\:
\gamma_i=\begin{cases}
1 &amp; \text{se $i$-esima variabile è nel modello}\\
0 &amp; \text{altrimenti}
\end{cases}\\[1.1ex]
&amp;\gamma_i \:\:\:\: \sim \: Be(\theta)\:\:\: \text{e}\:\:\: p_\gamma=\sum_{i=1}^{p}\gamma_i \:\:\:\: \sim \: Binom(p, \theta)
\end{split}  
\]</span></p>
<p>La distribuzione congiunta a posteriori risulta: <span class="math display">\[
\begin{split}
p(\beta_\gamma, u, \sigma^2_\epsilon, \sigma^2_u, \gamma, y | X) \:\:\: \propto \:\:&amp;
(\sigma^2_\epsilon)^{-n/2}exp\left\{-\frac{1}{2\sigma^2_\epsilon}(Y-X_\gamma\beta_\gamma - Zu)^T(Y-X_\gamma\beta_\gamma - Zu)\right\}\\[1.1ex]
&amp;\times \:(\sigma^2_\epsilon)^{-p_\gamma/2} \,|D_{0\gamma}|^{-1/2}\, exp\left\{ -\frac{1}{2\sigma^2_\epsilon} \beta^T_\gamma D_{0\gamma}^{-1} \beta_\gamma \right\}\\[1.1ex]
&amp;\times \: (\sigma^2_\epsilon)^{-\nu_\epsilon-1}\,exp\left\{-\frac{\lambda_\epsilon}{\sigma^2_\epsilon}\right\}\\[1.1ex]
&amp;\times \: (\sigma^2_u)^{k/2}\,exp\left\{-\frac{1}{2\sigma^2_u}u^Tu \right\}\\[1.1ex]
&amp;\times \: (\sigma^2_u)^{-\nu_u-1}\,exp\left\{ -\frac{\lambda_u}{\sigma^2_u} \right\}\\[1.1ex]
&amp;\times \: \theta^{\sum_{i=1}^{p}\gamma_i} \, (1-\theta)^{p- \sum_{i=1}^{p}\gamma_i}
\end{split}
\]</span> Full-conditional di <span class="math inline">\(\beta\)</span><br>
</p>
<p>Sia <span class="math inline">\(\epsilon_u=Y-Zu\)</span> : <span class="math display">\[
\begin{split}
p(\beta | -) \:\:\: &amp;\propto \:\: exp\left\{ -\frac{1}{2\sigma^2_\epsilon}\left(\epsilon_u - X_\gamma \beta_\gamma\right)^T \left(\epsilon_u - X_\gamma \beta_\gamma\right) -\frac{1}{2\sigma^2_\epsilon} \beta^T_\gamma D_{0\gamma}^{-1} \beta_\gamma\right\}\\[1.1ex]
&amp;\propto \:\: exp\left\{-\frac{1}{2\sigma^2_\epsilon}\left( \epsilon_u^T\epsilon_u - \epsilon_u^TX_\gamma\beta_\gamma - \beta_\gamma^T X^T_\gamma \epsilon_u  + \beta^T_\gamma X^T_\gamma X_\gamma \beta_\gamma \right) -\frac{1}{2\sigma^2_\epsilon} \beta^T_\gamma D^{-1}_{0\gamma} \beta_\gamma \right\}\\[1.1ex]
&amp;\propto \:\: exp\left\{ -\frac{1}{2\sigma^2_\epsilon} \left(-2\beta_\gamma^T X^T_\gamma \epsilon_u + \beta^T_\gamma X^T_\gamma X_\gamma \beta_\gamma \right) -\frac{1}{2\sigma^2_\epsilon}\beta^T_\gamma D_{0\gamma}^{-1} \beta_\gamma\right\}\\[1.1ex]
&amp;\propto \:\: exp\left\{ -\frac{1}{2\sigma^2_\epsilon} \left( -2\beta^T_\gamma (X^T_\gamma \epsilon_u) + \beta^T_\gamma (X^T_\gamma X_\gamma D_{0\gamma}^{-1})\beta_\gamma \right) \right\}
\end{split}
\]</span> Quindi <span class="math display">\[
\begin{split}
(\beta|-) \:\:\:\: \sim \: N_{p_\gamma} \left( \left(X^T_\gamma X_\gamma + D_{0\gamma}^{-1} \right)^{-1}X^T_\gamma \epsilon_u  \, , \, \sigma^2_\epsilon\left(X^T_\gamma X_\gamma + D_{0\gamma}^{-1} \right)^{-1}\right)
\end{split}
\]</span></p>
<p>Full-conditional di u<br>
Sia <span class="math inline">\(\epsilon_\beta=Y-X_\gamma \beta_\gamma\)</span>: <span class="math display">\[
\begin{split}
p(u | -) \:\:\: &amp;\propto \:\: exp\left\{ -\frac{1}{2\sigma^2_\epsilon}\left(\epsilon_\beta - Zu\right)^T \left(\epsilon_\beta - Zu\right) -\frac{1}{2\sigma^2_u} u^T u\right\}\\[1.1ex]
&amp;\propto \:\: exp\left\{-\frac{1}{2\sigma^2_\epsilon}\left( \epsilon_\beta^T\epsilon_\beta - 2u^T Z^T \epsilon_\beta + u^T Z^T Z u\right) -\frac{1}{2\sigma^2_u} u^T u\right\}\\[1.1ex]
&amp;\propto \:\: exp\left\{ -\frac{1}{2\sigma^2_\epsilon} \left(-2u^T Z^T \epsilon_\beta + u^T \left(Z^T Z + \frac{\sigma^2_\epsilon}{\sigma^2_u}I_k\right)u \right) \right \}
\end{split}
\]</span> Quindi: <span class="math display">\[
\begin{split}
(u | -) \:\:\:\: \sim \: N_{k}\left( \left(Z^TZ + \frac{\sigma^2_\epsilon}{\sigma^2_u}I_k\right)^{-1} Z^T \epsilon_\beta,  \sigma^2_\epsilon \left(Z^TZ + \frac{\sigma^2_\epsilon}{\sigma^2_u}I_k\right)^{-1}  \right)
\end{split}
\]</span> Full-conditional di <span class="math inline">\(\sigma^2_\epsilon\)</span><br>
Sia <span class="math inline">\(\epsilon_{TOT}=Y-X_\gamma \beta_\gamma - Zu\)</span>:</p>
<p><span class="math display">\[
\begin{split}
p(\sigma^2_\epsilon| -) \:\:\: &amp;\propto \:\: \left(\frac{1}{\sigma^2_\epsilon}\right)^{\frac{n}{2} + \frac{p_\gamma}{2} + \nu_\epsilon + 1} exp\left\{-\frac{1}{\sigma^2_\epsilon} \left( \frac{\epsilon_{TOT}^T \epsilon_{TOT}}{2} + \frac{\beta^T_\gamma D_{0\gamma}^{-1} \beta_\gamma}{2} + \lambda_\epsilon\right)\right\}
\end{split}
\]</span> Quindi: <span class="math display">\[
\begin{split}
(\sigma^2_\epsilon | -) \:\:\:\: \sim \: IG\left(\frac{n}{2} + \frac{p_\gamma}{2} + \nu_\epsilon ,  \, \frac{\epsilon_{TOT}^T \epsilon_{TOT}}{2} + \frac{\beta^T_\gamma D_{0\gamma}^{-1} \beta_\gamma}{2} + \lambda_\epsilon \right)
\end{split}
\]</span> Full-conditional di <span class="math inline">\(\sigma^2_u\)</span> <span class="math display">\[
\begin{split}
p(\sigma^2_u| -) \:\:\: &amp;\propto \:\: \left(\frac{1}{\sigma^2_u}\right)^{\frac{k}{2} + \nu_u +1} exp\left\{ -\frac{1}{2 \sigma^2_u} u^Tu - \frac{\lambda_u}{\sigma^2_u}\right\}\\[1.1ex]
&amp;\propto \:\: \left(\frac{1}{\sigma^2_u}\right)^{\frac{k}{2} + \nu_u +1} exp\left\{ -\frac{1}{ \sigma^2_u} \left(\frac{u^Tu}{2} +\lambda_u \right)\right\}
\end{split}
\]</span> Quindi: <span class="math display">\[
\begin{split}
(\sigma^2_u | -) \:\:\:\: \sim \: IG\left(\frac{k}{2} + \nu_u ,  \, \frac{u^Tu}{2} +\lambda_u \right)
\end{split}
\]</span> Distribuzione condizionata di <span class="math inline">\(\gamma\)</span>:<br>
Sia <span class="math display">\[
\begin{align*}
\epsilon_u= &amp; Y - Zu \\[1.1ex]
\end{align*}
\]</span></p>
<p>Consideriamo come costante tutto ciò che non dipende da <span class="math inline">\(\sigma^2_\epsilon, \sigma^2_u, u\)</span> ed integriamo via i parametri <span class="math inline">\(\beta\)</span> <span class="math display">\[
\begin{align*}
const=&amp;(\sigma^2_\epsilon)^{-\nu_\epsilon-1 - n/2}\,exp\left\{-\frac{\lambda_\epsilon}{\sigma^2_\epsilon}\right\}\\[1.1ex]
&amp;\times \: (\sigma^2_u)^{k/2}\,exp\left\{-\frac{1}{2\sigma^2_u}u^Tu \right\}\\[1.1ex]
&amp;\times \: (\sigma^2_u)^{-\nu_u-1}\,exp\left\{ -\frac{\lambda_u}{\sigma^2_u} \right\}\\[1.1ex]
&amp;\times \: \theta^{\sum_{i=1}^{p}\gamma_i} \, (1-\theta)^{p- \sum_{i=1}^{p}\gamma_i}\\[1.1ex]
\end{align*}
\]</span> <span class="math display">\[
\begin{align}
p(\gamma| u, \sigma^2_\epsilon, \sigma^2_u) &amp;\:\:\: \propto \:\: const \times (\sigma^2_\epsilon)^{-p_\gamma/2} \,|D_{0\gamma}|^{-1/2} \int exp\left\{ -\frac{\left( \epsilon_u - X_\gamma \beta_\gamma\right)^T\left( \epsilon_u - X_\gamma \beta_\gamma\right)}{2\sigma^2_\epsilon}  - \frac{\beta^T_\gamma D_{0\gamma}^{-1}\beta_\gamma}{2\sigma^2_\epsilon}\right\} \,d\beta_\gamma \notag \\[1.1ex]
&amp;\:\:\: = \:\: const \times (\sigma^2_\epsilon)^{-p_\gamma/2} \,|D_{0\gamma}|^{-1/2} \int exp\left\{ -\frac{\left(\epsilon_u^T \epsilon_u -2\beta_\gamma^T X_\gamma^T \epsilon_u + \beta_\gamma^T X_\gamma^T X_\gamma \beta_\gamma\right)}{2\sigma^2_\epsilon}   -\frac{\beta_\gamma^T D_{0\gamma}^{-1} \beta_\gamma}{2\sigma^2_\epsilon}\right\}\,d\beta_\gamma \notag  \\[1.1ex]
&amp;\:\:\: = \:\: const \times (\sigma^2_\epsilon)^{-p_\gamma/2} \,|D_{0\gamma}|^{-1/2} \int exp \left\{ -\frac{\epsilon_u^T \epsilon_u}{2\sigma^2_\epsilon} + \frac{\beta_\gamma^T X_\gamma^T \epsilon_u }{\sigma^2_\epsilon} - \frac{\beta_\gamma^T X_\gamma^T X_\gamma \beta_\gamma}{2 \sigma^2_\epsilon} - \frac{\beta^T_\gamma D_{0\gamma}^{-1} \beta_\gamma}{2 \sigma^2_\epsilon}\right\}\,d\beta_\gamma \notag   \\[1.1ex]
&amp;\:\:\: = \:\: const \times  (\sigma^2_\epsilon)^{-p_\gamma/2} \,|D_{0\gamma}|^{-1/2} \, exp \left\{ -\frac{\epsilon_u^T \epsilon_u}{2\sigma^2_\epsilon} \right\} \int  exp \left\{\frac{\beta_\gamma^T X_\gamma^T \epsilon_u }{\sigma^2_\epsilon} - \frac{\beta_\gamma^T X_\gamma^T X_\gamma \beta_\gamma}{2 \sigma^2_\epsilon} - \frac{\beta^T_\gamma D_{0\gamma}^{-1} \beta_\gamma}{2 \sigma^2_\epsilon} \right\}\, d\beta_\gamma \notag   \\[1.1ex]
&amp;\:\:\: = \:\: const \times (\sigma^2_\epsilon)^{-p_\gamma/2} \,|D_{0\gamma}|^{-1/2} \, exp \left\{ -\frac{\epsilon_u^T \epsilon_u}{2\sigma^2_\epsilon} \right\} \int exp \left\{\frac{\beta_\gamma^T X_\gamma^T \epsilon_u }{\sigma^2_\epsilon}   - \frac{\beta_\gamma^T \left( X^T_\gamma X_\gamma + D_{0\gamma}^{-1} \right) \beta_\gamma}{2\sigma^2_\epsilon} \right \} \, d\beta_\gamma \notag   \\[1.1ex]
\end{align}
\]</span></p>
<p>A questo punto riconosciamo una distribuzione normale, definita a meno di costanti di normalizzazione, per i parametri beta nell’integrale.</p>
<p>Moltiplichiamo e dividiamo per le costanti di normalizzazione ed integriamo via la distribuzione normale (che integrerà ora a 1).</p>
<p><span class="math display">\[
\begin{align}
p(\gamma| u, \sigma^2_\epsilon, \sigma^2_u) &amp;\:\:\: \propto \:\: const \times (\sigma^2_\epsilon)^{-p_\gamma/2} \,|D_{0\gamma}|^{-1/2} \, exp \left\{ -\frac{\epsilon_u^T \epsilon_u}{2\sigma^2_\epsilon} \right\} \int
    \begin{aligned}[t]
           &amp; |( X_\gamma^T X_\gamma + D_{0\gamma}^{-1})^{-1}|^{-\frac{1}{2}}| (X_\gamma^T X_\gamma + D_{0\gamma}^{-1})^{-1}|^{\frac{1}{2}} \left(\sigma^2_\epsilon\right)^{\frac{1}{2}} \left(\sigma^2_\epsilon\right)^{-\frac{1}{2}}  \\[1.1ex]                                     &amp;  exp
           \left \{
               -\frac{(X_\gamma^TX_\gamma + D_{0\gamma}^{-1})\mu^T \mu}{2\sigma^2_\epsilon} + \frac{\epsilon^T_u X_\gamma \beta_\gamma}{\sigma^2_\epsilon}  \right.\\[1.1ex]        
              &amp;\left.-\frac{\beta_\gamma^T (X_\gamma^TX_\gamma + D_{0\gamma}^{-1})\beta_\gamma}{2\sigma^2_\epsilon} + \frac{(X_\gamma^TX_\gamma + D_{0\gamma}^{-1})\mu^T \mu}{2\sigma^2_\epsilon}
          \right\}
          \, d\beta_\gamma
    \end{aligned} \notag  \\[1.1ex]
&amp;\:\:\: = \:\: const \times  (\sigma^2_\epsilon)^{-p_\gamma/} \,|D_{0\gamma}|^{-1/2} \, exp \left\{ -\frac{\epsilon_u^T \epsilon_u}{2\sigma^2_\epsilon} \right\}|( X_\gamma^T X_\gamma + D_{0\gamma}^{-1})^{-1}|^{\frac{1}{2}} \left(\sigma^2_\epsilon\right)^{\frac{1}{2}} exp \left\{\frac{(X_\gamma^TX_\gamma + D_{0\gamma}^{-1})\mu^T \mu}{2\sigma^2_\epsilon}\right\}   \notag  \\[1.1ex]
&amp; \quad \:\:\: \times \:\: \int
    \begin{aligned}[t]
           &amp; |( X_\gamma^T X_\gamma + D_{0\gamma}^{-1})^{-1}|^{-\frac{1}{2}}\left(\sigma^2_\epsilon\right)^{-\frac{1}{2}} exp\left \{-\frac{ ( X_\gamma^TX_\gamma + D_{0\gamma}^{-1}) \mu^T \mu}{2\sigma^2_\epsilon} + \frac{\epsilon^T_u X_\gamma \beta_\gamma}{\sigma^2_\epsilon}\right. \notag \\[1.1ex]
            &amp; \left.   -\frac{\beta_\gamma^T (X_\gamma^TX_\gamma + D_{0\gamma}^{-1})\beta_\gamma}{2\sigma^2_\epsilon}\right\}
          \, d\beta_\gamma
    \end{aligned} \notag  \\[1.1ex]
&amp;\:\:\: = \:\: const \times (\sigma^2_\epsilon)^{-p_\gamma/2} \,|D_{0\gamma}|^{-1/2} \, exp \left\{ -\frac{\epsilon_u^T \epsilon_u}{2\sigma^2_\epsilon} \right\}| (X_\gamma^T X_\gamma + D_{0\gamma}^{-1})^{-1}|^{\frac{1}{2}} \left(\sigma^2_\epsilon\right)^{\frac{1}{2}} exp \left\{\frac{(X_\gamma^TX_\gamma + D_{0\gamma}^{-1})\mu^T \mu}{2\sigma^2_\epsilon}\right\}   \notag  \\[1.1ex]
&amp;\:\:\: \propto \:\: (\sigma^2_\epsilon)^{-p_\gamma/2} |D_{0\gamma}|^{-1/2} \theta^{\sum_{i=1}^{p}\gamma_i} \, (1-\theta)^{p- \sum_{i=1}^{p}\gamma_i} |( X_\gamma^T X_\gamma + D_{0\gamma}^{-1})^{-1}|^{\frac{1}{2}} \notag  \\[1.1ex]
&amp; \quad \:\:\: \times \:\: exp \left \{ \frac{1}{2\sigma^2_\epsilon}(X_\gamma^TX_\gamma + D_{0\gamma}^{-1}) \epsilon_u^T X_\gamma (X_\gamma^TX_\gamma + D_{0\gamma}^{-1})^{-1}(X_\gamma^TX_\gamma + D_{0\gamma}^{-1})^{-1} X^T \epsilon_u\right\}
\end{align}
\]</span> Quindi si ottiene: <span class="math display">\[
\begin{split}
p(\gamma| u, \sigma^2_\epsilon,\sigma^2_u) &amp;\:\:\: \propto \:\: |D_{0\gamma}|^{-1/2} \theta^{\sum_{i=1}^{p}\gamma_i} \, (1-\theta)^{p- \sum_{i=1}^{p}\gamma_i} | (X_\gamma^T X_\gamma + D_{0\gamma}^{-1})^{-1}|^{\frac{1}{2}} \notag  \\[1.1ex]
&amp; \quad \:\:\: \times \:\: exp \left \{ \frac{1}{2\sigma^2_\epsilon} \epsilon^T_u X_\gamma (X_\gamma^TX_\gamma + D_{0\gamma}^{-1})^{-1} X_\gamma^T \epsilon_u\right\}
\end{split}
\]</span></p>
<section id="spike-slab-priors-per-linear-mixed-models-codifica" class="level2">
<h2 class="anchored" data-anchor-id="spike-slab-priors-per-linear-mixed-models-codifica">Spike &amp; Slab Priors per Linear Mixed Models: codifica</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># funzione che calcola la marginale di gamma</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>pi_gamma <span class="ot">&lt;-</span> <span class="cf">function</span>(gamma, sigma_e, theta, Z, data, response, v, u)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># v parameter of the prior variance (in D0)</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># n and p are sample size and number of parameter</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># assume prior beta0 = 0 </span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># the intercept is always included</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>((data[, response]))</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>response)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  p <span class="ot">&lt;-</span> <span class="fu">length</span>(gamma)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  p_u <span class="ot">&lt;-</span> <span class="fu">ncol</span>(Z)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(data)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># calcolo le quantità per inizializzare la componente di metropolis</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  pos_gamma <span class="ot">&lt;-</span> <span class="fu">which</span>(gamma <span class="sc">==</span> <span class="dv">1</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  X <span class="ot">&lt;-</span> <span class="fu">sparse.model.matrix</span>(<span class="sc">~</span>., <span class="at">data =</span> data[, pos_gamma])</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># costruisco le quantità da passare a pi_gamma e per generare i parametri</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  D <span class="ot">&lt;-</span> <span class="fu">Diagonal</span>(<span class="fu">ncol</span>(X))<span class="sc">*</span>v</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  D_inv <span class="ot">&lt;-</span> <span class="fu">Diagonal</span>(<span class="fu">ncol</span>(X))<span class="sc">*</span>(<span class="dv">1</span><span class="sc">/</span>v)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>  XtX <span class="ot">&lt;-</span> <span class="fu">crossprod</span>(X) <span class="sc">+</span> D_inv</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>  XtX_inv <span class="ot">&lt;-</span> <span class="fu">chol2inv</span>(<span class="fu">chol</span>(XtX))</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>  epsilon_u <span class="ot">&lt;-</span> y <span class="sc">-</span> Z <span class="sc">%*%</span> u</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>  S <span class="ot">&lt;-</span> <span class="fu">quad.tform</span>(XtX_inv, <span class="fu">as.vector</span>(<span class="fu">crossprod</span>(epsilon_u, X)))</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>  m_like <span class="ot">&lt;-</span> <span class="sc">-</span> (<span class="fl">0.5</span><span class="sc">*</span><span class="fu">sum</span>(gamma))<span class="sc">*</span><span class="fu">log</span>(sigma_e) <span class="sc">-</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0.5</span><span class="sc">*</span><span class="fu">determinant</span>(D, <span class="at">logarithm =</span> T)<span class="sc">$</span>modulus <span class="sc">+</span> </span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="fu">dbinom</span>(<span class="fu">sum</span>(gamma), p, theta, <span class="at">log =</span> T)  <span class="sc">+</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0.5</span><span class="sc">*</span><span class="fu">determinant</span>(XtX_inv, <span class="at">logarithm =</span> T)<span class="sc">$</span>modulus <span class="sc">+</span> <span class="dv">1</span><span class="sc">/</span>(<span class="dv">2</span><span class="sc">*</span>sigma_e) <span class="sc">*</span> S <span class="sc">-</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span><span class="sc">/</span>(<span class="dv">2</span><span class="sc">*</span>sigma_e) <span class="sc">*</span> <span class="fu">crossprod</span>(epsilon_u)</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">mlike =</span> m_like, <span class="at">XtX =</span> XtX, <span class="at">D =</span> D, <span class="at">D_inv =</span> D_inv, </span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>              <span class="at">XtX_inv =</span> XtX_inv, <span class="at">epsilon_u =</span> epsilon_u, <span class="at">X =</span> X, <span class="at">gamma =</span> gamma))</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a><span class="co"># gibbs sampler</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>gibbs_spikeslab <span class="ot">&lt;-</span> <span class="cf">function</span>(R, beta_init, sigma_init, u_init, gamma_init, data, Z, response, theta,</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>                            ni_e, ni_u, lambda_e, lambda_u, v, <span class="at">verbose =</span> T)</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>((data[, response]))</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>  p_b <span class="ot">&lt;-</span> <span class="fu">length</span>(gamma_init)</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>  p_u <span class="ot">&lt;-</span> <span class="fu">ncol</span>(Z)</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>  p <span class="ot">&lt;-</span> <span class="fu">length</span>(gamma_init)</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(data)</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>  par_init <span class="ot">&lt;-</span> <span class="fu">c</span>(u_init, sigma_init)</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>  <span class="co"># matrici che conterrà le simulazioni</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>  parout <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, R<span class="sc">+</span><span class="dv">1</span>, <span class="fu">length</span>(par_init))</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>  gammaout <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, R<span class="sc">+</span><span class="dv">1</span>, <span class="fu">length</span>(gamma_init))</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>  beta_list <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(gammaout) <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>response) <span class="sc">%&gt;%</span> colnames</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>  <span class="co"># inserisco i parametri inizializzati</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>  gammaout[<span class="dv">1</span>, ] <span class="ot">&lt;-</span> gamma_init</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>  parout[<span class="dv">1</span>, ] <span class="ot">&lt;-</span> par_init</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>  beta_list[[<span class="dv">1</span>]] <span class="ot">&lt;-</span> beta_init</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>  <span class="co"># fisso i valori di inizializzazione dell'algoritmo</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>  m_0 <span class="ot">&lt;-</span> <span class="fu">pi_gamma</span>(gamma_init, <span class="at">sigma_e =</span> par_init[<span class="fu">length</span>(par_init)<span class="sc">-</span><span class="dv">1</span>], </span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>                  <span class="at">theta =</span> theta, Z, data, response, v, par_init[<span class="dv">1</span><span class="sc">:</span>p_u])</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>  gamma0 <span class="ot">&lt;-</span> gamma_init </span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>  <span class="co"># matrice servirà in seguito</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>  Z <span class="ot">&lt;-</span> <span class="fu">Matrix</span>(Z)</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>  ZtZ <span class="ot">&lt;-</span> <span class="fu">crossprod</span>(Z)</span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>R)</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>    gamma1 <span class="ot">&lt;-</span> gamma0</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>    <span class="co"># proposal per gamma in cui cambia solo un indicatore alla volta</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>    pos <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>p, <span class="at">size =</span> <span class="dv">1</span>)</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ifelse</span>(gamma1[pos]<span class="sc">==</span><span class="dv">0</span>, gamma1[pos] <span class="ot">&lt;-</span> <span class="dv">1</span>, gamma1[pos] <span class="ot">&lt;-</span> <span class="dv">0</span>)</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>    m_1 <span class="ot">&lt;-</span> <span class="fu">pi_gamma</span>(gamma1, <span class="at">sigma_e =</span> parout[i, <span class="fu">length</span>(par_init)<span class="sc">-</span><span class="dv">1</span>], </span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>                    <span class="at">theta =</span> theta, Z, data, response, v, parout[i, <span class="dv">1</span><span class="sc">:</span>p_u])</span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>    m_0 <span class="ot">&lt;-</span>  <span class="fu">pi_gamma</span>(gamma0, <span class="at">sigma_e =</span> parout[i, <span class="fu">length</span>(par_init)<span class="sc">-</span><span class="dv">1</span>], </span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>                     <span class="at">theta =</span> theta, Z, data, response, v, parout[i, <span class="dv">1</span><span class="sc">:</span>p_u])</span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>    alpha <span class="ot">&lt;-</span> <span class="fu">exp</span>(m_1<span class="sc">$</span>mlike <span class="sc">-</span> m_0<span class="sc">$</span>mlike) <span class="co"># prob di accettazione della proposta</span></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">as.numeric</span>(<span class="fu">runif</span>(<span class="dv">1</span>) <span class="sc">&lt;</span> alpha))</span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>      gamma0 <span class="ot">&lt;-</span> gamma1</span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>      m_0 <span class="ot">&lt;-</span> m_1</span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>    gammaout[i<span class="sc">+</span><span class="dv">1</span>, ] <span class="ot">&lt;-</span> gamma0</span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>    <span class="co"># genero i beta</span></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>    sigma_e <span class="ot">&lt;-</span> parout[i, <span class="fu">length</span>(par_init)<span class="sc">-</span><span class="dv">1</span>]</span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>    epsilon_u <span class="ot">&lt;-</span> y <span class="sc">-</span> Z <span class="sc">%*%</span> parout[i, <span class="dv">1</span><span class="sc">:</span>p_u]</span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>    beta_list[[i<span class="sc">+</span><span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">rmvn.sparse</span>(<span class="dv">1</span>, <span class="at">mu =</span> m_0<span class="sc">$</span>XtX_inv <span class="sc">%*%</span> <span class="fu">crossprod</span>(m_0<span class="sc">$</span>X, epsilon_u),</span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>                                              <span class="at">CH =</span> <span class="fu">Cholesky</span>(m_0<span class="sc">$</span>XtX_inv <span class="sc">*</span> sigma_e))</span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a>    <span class="fu">colnames</span>(beta_list[[i<span class="sc">+</span><span class="dv">1</span>]]) <span class="ot">&lt;-</span> <span class="fu">colnames</span>(m_0<span class="sc">$</span>X)</span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a>    <span class="co"># genero gli u</span></span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>    sigma_u <span class="ot">&lt;-</span> parout[i, <span class="fu">length</span>(par_init)]</span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">&lt;-</span> <span class="fu">Diagonal</span>(<span class="fu">ncol</span>(ZtZ)) <span class="sc">*</span> (sigma_e <span class="sc">/</span> sigma_u)</span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>    epsilon_b <span class="ot">&lt;-</span> y <span class="sc">-</span> m_0<span class="sc">$</span>X <span class="sc">%*%</span> <span class="fu">as.vector</span>(beta_list[[i<span class="sc">+</span><span class="dv">1</span>]])</span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>    parout[i<span class="sc">+</span><span class="dv">1</span>, <span class="dv">1</span><span class="sc">:</span>p_u] <span class="ot">&lt;-</span> <span class="fu">rmvn.sparse</span>(<span class="dv">1</span>, <span class="at">mu =</span> <span class="fu">chol2inv</span>(<span class="fu">chol</span>(ZtZ <span class="sc">+</span> B)) <span class="sc">%*%</span> <span class="fu">crossprod</span>(Z, epsilon_b),</span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">CH =</span> <span class="fu">Cholesky</span>(<span class="dv">1</span><span class="sc">/</span>sigma_e <span class="sc">*</span> (ZtZ <span class="sc">+</span> B)))<span class="sc">@</span>x</span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a>    <span class="co"># genero sigma epsilon </span></span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a>    epsilon_tot <span class="ot">&lt;-</span> epsilon_b <span class="sc">-</span> Z <span class="sc">%*%</span> parout[i<span class="sc">+</span><span class="dv">1</span>, <span class="dv">1</span><span class="sc">:</span>p_u]</span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a>    beta_cor <span class="ot">&lt;-</span> <span class="fu">as.vector</span>(beta_list[[i<span class="sc">+</span><span class="dv">1</span>]])</span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a>    p_gamma <span class="ot">&lt;-</span> <span class="fu">sum</span>(gammaout[i<span class="sc">+</span><span class="dv">1</span>, ] )</span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a>    parout[i<span class="sc">+</span><span class="dv">1</span>, <span class="fu">length</span>(par_init)<span class="sc">-</span><span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span><span class="fu">rgamma</span>(<span class="dv">1</span>, (n<span class="sc">/</span><span class="dv">2</span> <span class="sc">+</span> ni_e <span class="sc">+</span> p_gamma<span class="sc">/</span><span class="dv">2</span>),</span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a>                                                <span class="fu">drop</span>(<span class="fu">crossprod</span>(epsilon_tot)<span class="sc">/</span><span class="dv">2</span> <span class="sc">+</span> </span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a>                                                   <span class="fu">quad.form</span>(m_0<span class="sc">$</span>D_inv, beta_cor)<span class="sc">/</span><span class="dv">2</span> <span class="sc">+</span> </span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a>                                                   lambda_e))</span>
<span id="cb2-106"><a href="#cb2-106" aria-hidden="true" tabindex="-1"></a>    <span class="co"># genero sigma_u</span></span>
<span id="cb2-107"><a href="#cb2-107" aria-hidden="true" tabindex="-1"></a>    u_cor <span class="ot">&lt;-</span> parout[i<span class="sc">+</span><span class="dv">1</span>, <span class="dv">1</span><span class="sc">:</span>p_u]</span>
<span id="cb2-108"><a href="#cb2-108" aria-hidden="true" tabindex="-1"></a>    parout[i<span class="sc">+</span><span class="dv">1</span>, <span class="fu">length</span>(par_init)] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span><span class="fu">rgamma</span>(<span class="dv">1</span>, ni_u <span class="sc">+</span> p_u<span class="sc">/</span><span class="dv">2</span>, (<span class="fu">crossprod</span>(u_cor)<span class="sc">/</span><span class="dv">2</span> <span class="sc">+</span> lambda_u))</span>
<span id="cb2-109"><a href="#cb2-109" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-110"><a href="#cb2-110" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(verbose<span class="sc">==</span>T <span class="sc">&amp;</span> (i <span class="sc">%%</span> <span class="dv">100</span>) <span class="sc">==</span> <span class="dv">0</span>) <span class="fu">print</span>(i)</span>
<span id="cb2-111"><a href="#cb2-111" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-112"><a href="#cb2-112" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">beta =</span> beta_list, <span class="at">parameters =</span> parout, <span class="at">gamma =</span> gammaout))</span>
<span id="cb2-113"><a href="#cb2-113" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="dataset-football-data-from-transfermarkt" class="level1">
<h1>Dataset: Football Data from Transfermarkt</h1>
<p>I dati a nostra disposizione sono stati reperiti dal sito <a href="https://www.kaggle.com/datasets/davidcariboo/player-scores?select=competitions.csv">Kaggle</a> e forniscono informazioni su alcuni giocatori di calcio professionisti, sulle partite da loro sostenute e sui club a cui appartengono (dal 2012 al 2024). Il dataset è stato composto a partire da una serie di CSV strutturati nel seguente modo:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="file_collegamenti_dataset.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>Per esempio, <em>players</em> contiene informazioni sui giocatori, quali il loro nome, la loro cittadinanza, etc.; <em>player_valutations</em> contiene il valore di mercato (in euro) di ciascun giocatore; <em>appearances</em> contiene per ogni record le prestazioni di una partita in cui un giocatore ha preso parte.</p>
<p>L’insieme dei dati sulle valutazioni di mercato contiene naturalmente meno record rispetto all’insieme di dati sulle partite, questo perchè il valore di mercato viene registrato con una frequenza (circa) semestrale, mentre le partite settimanalmente. Abbiamo quindi deciso di aggregare le informazioni sulle prestazioni in campo dei giocatori in semestri, ottenendo così per ogni giocatore delle statistiche di performance semestrali ed un associato valore di mercato (variabile risposta).</p>
<p>Si ha inoltre che per ogni partita (dataframe appearances) abbiamo a disposizione il tipo di competizione in cui è stata giocata (ad es. campionato, coppa internazionale …), dato che si ritiene che le performance di partita abbiano un’influenza sulla risposta differente a seconda del fatto che la partita sia un’amichevole o una partita di champion league, nell’aggregare i dati semestralmente si è creata l’interazione tra le statistiche di performance e la competizione. Ad esempio per ogni giocatore si sono crete le variabili “numero gi goal in campionato”, “numero di goal nelle coppe internazionali” …</p>
<p>Il dataset costruito presenta circa 110 mila righe e 43 variabili:</p>
<section id="analisi-esplorative" class="level2">
<h2 class="anchored" data-anchor-id="analisi-esplorative">Analisi esplorative</h2>
<p>Di seguito vengono riportate alcune analisi esplorative sui dati.</p>
<p>Distribuzione della variabile risposta:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>p1<span class="ot">=</span>newdata <span class="sc">%&gt;%</span> </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> mkval)) <span class="sc">+</span> </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>(<span class="fu">aes</span>(<span class="at">y =</span> ..density..)) <span class="sc">+</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Valore di mercato"</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>newdata<span class="sc">$</span>log_mkval <span class="ot">&lt;-</span> <span class="fu">log</span>(newdata<span class="sc">$</span>mkval)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>p2<span class="ot">=</span>newdata <span class="sc">%&gt;%</span> </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> log_mkval)) <span class="sc">+</span> </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>(<span class="fu">aes</span>(<span class="at">y =</span> ..density..), <span class="at">bins =</span> <span class="dv">20</span>) <span class="sc">+</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Log valore di mercato"</span>) <span class="sc">+</span> </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">stat_overlay_normal_density</span>(<span class="at">color =</span> <span class="st">"red"</span>, <span class="at">linetype =</span> <span class="st">"dashed"</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>gridExtra<span class="sc">::</span><span class="fu">grid.arrange</span>(p1,p2, <span class="at">ncol=</span><span class="dv">2</span>)</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.
ℹ Please use `after_stat(density)` instead.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BVS_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Si nota che la variabile risposta presenta un andamento fortemente asimmetrico: la maggior parte dei giocatori presentano valori di mercato bassi (il valore di mercato minimo è pari a 10000 euro). Tuttavia, l’utilizzo della trasformata logaritmica migliora di molto la situazione.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>newdata <span class="sc">%&gt;%</span> <span class="fu">group_by</span>(player_id) <span class="sc">%&gt;%</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> Age, <span class="at">y =</span> mkval, </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">group =</span> <span class="fu">as.numeric</span>(player_id), <span class="at">col =</span> <span class="fu">as.numeric</span>(player_id))) <span class="sc">+</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Età"</span>) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">"Valore di mercato"</span>) <span class="sc">+</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_gradientn</span>(<span class="at">colours =</span> <span class="fu">rainbow</span>(<span class="dv">10</span>)) <span class="sc">+</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position=</span><span class="st">"none"</span>) </span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BVS_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>In questo grafico si riporta, per ciascun giocatore, l’andamento nel tempo del proprio valore di mercato: notiamo che la maggior parte dei calciatori ha un’età inferiore ai 35 anni e un valore di mercato non superiore ai 50 mln.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># valuto l'interazione con la posizione del giocatore</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> newdata <span class="sc">%&gt;%</span> <span class="fu">filter</span>(position <span class="sc">==</span> <span class="st">"Defender"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">y =</span> mkval, <span class="at">x =</span> <span class="fu">jitter</span>(typedomestic_league_x_month_goal, <span class="at">factor =</span> <span class="dv">2</span>))) <span class="sc">+</span> </span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span> </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_smooth</span>() <span class="sc">+</span> </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Goal"</span>) <span class="sc">+</span> </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Defender"</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> newdata <span class="sc">%&gt;%</span> <span class="fu">filter</span>(position <span class="sc">==</span> <span class="st">"Attack"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">y =</span> mkval, <span class="at">x =</span> <span class="fu">jitter</span>(typedomestic_league_x_month_goal, <span class="at">factor =</span> <span class="dv">2</span>))) <span class="sc">+</span> </span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span> </span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_smooth</span>() <span class="sc">+</span> </span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Goal"</span>) <span class="sc">+</span> </span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Attack"</span>)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">&lt;-</span> newdata <span class="sc">%&gt;%</span> <span class="fu">filter</span>(position <span class="sc">==</span> <span class="st">"Midfield"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">y =</span> mkval, <span class="at">x =</span> <span class="fu">jitter</span>(typedomestic_league_x_month_goal, <span class="at">factor =</span> <span class="dv">2</span>))) <span class="sc">+</span> </span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span> </span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_smooth</span>() <span class="sc">+</span> </span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Goal"</span>) <span class="sc">+</span> </span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Midfield"</span>)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>figure <span class="ot">&lt;-</span> <span class="fu">ggarrange</span>(p1, p2, p3,  <span class="at">nrow =</span> <span class="dv">1</span>, <span class="at">ncol =</span> <span class="dv">3</span>) </span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = "cs")'
`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = "cs")'
`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = "cs")'</code></pre>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">annotate_figure</span>(figure,</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">bottom =</span> <span class="fu">text_grob</span>(<span class="st">"Valore di mercato in funzione del numero di goal in campionato a seconda del ruolo del giocatore"</span>, </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">color =</span> <span class="st">"black"</span>,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">hjust =</span> <span class="dv">1</span>, <span class="at">x =</span> <span class="dv">1</span>, <span class="at">face =</span> <span class="st">"italic"</span>, <span class="at">size =</span> <span class="dv">10</span>),</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">left =</span> <span class="fu">text_grob</span>(<span class="st">"Valori di mercato"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">rot =</span> <span class="dv">90</span>),</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>                <span class="at">fig.lab =</span> <span class="st">"Figure 1"</span>, <span class="at">fig.lab.face =</span> <span class="st">"bold"</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BVS_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Qui vediamo riportato l’andamento del valore di mercato in funzione del numero di goal a seconda del ruolo del giocatore. Non sorprende che a beneficiare maggiormente di un numero elevato di goal siano gli attaccanti (da notare come, a partire dai 10 goal, ci sia un’impennata del valore di mercato).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># e l'interazione con il campionato </span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>newdata <span class="sc">%&gt;%</span> </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">y =</span> mkval, <span class="at">x =</span> <span class="fu">jitter</span>(typedomestic_league_x_month_goal, <span class="at">factor =</span> <span class="dv">2</span>))) <span class="sc">+</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span> </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_smooth</span>() <span class="sc">+</span> </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>player_club_domestic_competition_id) <span class="sc">+</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Goal"</span>) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">"Valore di mercato"</span>)</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = "cs")'</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BVS_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>In questo grafico ogni panel rappresenta una competizione diversa, identificata dalle sigle come BE1, DK1, etc. (indicatori delle diverse leghe/campionati). In alcune leghe, come la Premier League (GB1), si osserva una grande concentrazione di giocatori con valori di mercato alti e un numero variabile di goal. In altre leghe, come la Super League (GR1) e la Premier League russa (RU1), la concentrazione di valori di mercato piè alti è meno evidente.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>tmpdata <span class="ot">&lt;-</span> newdata <span class="sc">%&gt;%</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(<span class="fu">across</span>(<span class="fu">where</span>(is.numeric), scale))  </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>mu_data <span class="ot">&lt;-</span> <span class="fu">colMeans</span>(newdata <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="fu">where</span>(is.numeric)))</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>sigma_data <span class="ot">&lt;-</span> <span class="fu">apply</span>(newdata<span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="fu">where</span>(is.numeric)), <span class="dv">2</span>, var)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>tmpdata<span class="sc">$</span>player_id <span class="ot">&lt;-</span> newdata<span class="sc">$</span>player_id</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>tmpdata<span class="sc">$</span>mkval <span class="ot">&lt;-</span> newdata<span class="sc">$</span>mkval</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>tmpdata<span class="sc">$</span>log_mkval <span class="ot">&lt;-</span> newdata<span class="sc">$</span>log_mkval</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>newdata <span class="ot">&lt;-</span> tmpdata</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>newdata<span class="sc">$</span>Age2 <span class="ot">&lt;-</span> newdata<span class="sc">$</span>Age<span class="sc">**</span><span class="dv">2</span></span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">989</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>plid <span class="ot">&lt;-</span> <span class="fu">unique</span>(newdata<span class="sc">$</span>player_id) <span class="sc">%&gt;%</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sample</span>(<span class="at">size =</span> <span class="fl">0.30</span><span class="sc">*</span><span class="fu">length</span>(<span class="fu">unique</span>(newdata<span class="sc">$</span>player_id)))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co"># dati in cui verifico la bontÃ&nbsp; di adattamento dei vari modelli</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>te_data <span class="ot">&lt;-</span> newdata <span class="sc">%&gt;%</span> <span class="fu">filter</span>(player_id <span class="sc">%in%</span> plid) <span class="sc">%&gt;%</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(player_id) <span class="sc">%&gt;%</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(year_Q) <span class="sc">%&gt;%</span> </span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="fu">row_number</span>() <span class="sc">==</span> <span class="fu">n</span>()) <span class="sc">%&gt;%</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ungroup</span>()</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>te_data <span class="ot">&lt;-</span> te_data <span class="sc">%&gt;%</span> <span class="fu">filter</span>(country_of_citizenship <span class="sc">!=</span> <span class="st">"St. Lucia"</span>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co"># dati di stima dei vari modelli</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>tr_data <span class="ot">&lt;-</span> newdata <span class="sc">%&gt;%</span> <span class="fu">filter</span>(player_id <span class="sc">%in%</span> plid) <span class="sc">%&gt;%</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(player_id) <span class="sc">%&gt;%</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(year_Q) <span class="sc">%&gt;%</span> </span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="fu">row_number</span>() <span class="sc">&lt;</span> <span class="fu">n</span>()) <span class="sc">%&gt;%</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rbind.data.frame</span>(newdata <span class="sc">%&gt;%</span> <span class="fu">filter</span>(<span class="sc">!</span>(player_id <span class="sc">%in%</span> plid))) <span class="sc">%&gt;%</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>  ungroup</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>te_data <span class="ot">&lt;-</span> te_data <span class="sc">%&gt;%</span> <span class="fu">arrange</span>(player_id) </span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>tr_data <span class="ot">&lt;-</span> tr_data <span class="sc">%&gt;%</span> <span class="fu">arrange</span>(player_id) </span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>te_data <span class="ot">&lt;-</span> te_data <span class="sc">|&gt;</span> <span class="fu">filter</span>(<span class="sc">!</span>(country_of_citizenship <span class="sc">%in%</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>      <span class="fu">setdiff</span>(<span class="fu">unique</span>(te_data<span class="sc">$</span>country_of_citizenship),</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>              <span class="fu">unique</span>(tr_data<span class="sc">$</span>country_of_citizenship))))</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Al fine di confrontare modelli differenti si dividono i dati, precedentemente standardizzati, in un insieme di stima e uno di verifica. In particolare, si sono selezionati casualmente il 30% dei giocatori e per ognuno di essi si è preso l’ultimo valore osservato per comporre l’insieme di verifica.</p>
</section>
<section id="un-semplice-modello-lineare" class="level2">
<h2 class="anchored" data-anchor-id="un-semplice-modello-lineare">Un semplice modello lineare</h2>
<p>Sfruttando solo alcune delle variabili a disposizione, si decide di implementare un semplice modello lineare coniugato:</p>
<p><span class="math display">\[
y_i = x_i^T \beta + \epsilon_i,\quad i=1,...,n   
\]</span> <span class="math display">\[
\sigma^2_\epsilon \: \sim \: IG(\nu, \lambda) , \quad \beta|\sigma_\epsilon^2 \: \sim \: N(\beta_0, \sigma^2_\epsilon D_0).
\]</span> Il primo passo passo per stimare un modello in stan è costruire una lista contenente i dati necessari per la stima del modello</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>data_list <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>data_list<span class="sc">$</span>y <span class="ot">&lt;-</span> tr_data<span class="sc">$</span>log_mkval <span class="co"># variabile risposta per il modello</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>prednames <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Age"</span>, <span class="st">"Age2"</span>, <span class="st">"sub_position"</span>, <span class="st">"year_Q"</span>, </span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>               <span class="st">"typedomestic_league_x_month_min_palyed"</span>, </span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>               <span class="st">"typedomestic_league_x_month_goal"</span>,</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>               <span class="st">"typedomestic_league_x_month_assists"</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co"># covariate per la stima:</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> tr_data <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="fu">all_of</span>(prednames))</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">#Creiamo le dummy per la variabile sub_position:</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>Xmat <span class="ot">&lt;-</span> <span class="fu">dummy_cols</span>(X, <span class="at">select_columns =</span> <span class="st">"sub_position"</span>, <span class="at">remove_first_dummy =</span> T,</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>                <span class="at">remove_selected_columns =</span> T)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>Xmat <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="dv">1</span>, Xmat)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>data_list<span class="sc">$</span>X <span class="ot">&lt;-</span> Xmat </span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="co"># covariate per il test set:</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>Xtest <span class="ot">&lt;-</span> te_data <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="fu">all_of</span>(prednames))</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>Xmat_test <span class="ot">&lt;-</span> <span class="fu">dummy_cols</span>(Xtest, <span class="at">select_columns =</span> <span class="st">"sub_position"</span>, <span class="at">remove_first_dummy =</span> T,</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>                <span class="at">remove_selected_columns =</span> T)</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>Xmat_test <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="dv">1</span>, Xmat_test)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>data_list<span class="sc">$</span>Xtest <span class="ot">&lt;-</span> Xmat_test</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>data_list<span class="sc">$</span>D0 <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="fu">ncol</span>(Xmat)) <span class="sc">*</span> <span class="dv">10</span><span class="sc">**</span><span class="dv">2</span> <span class="co"># matrice delle covarianze dei parametri a priori</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>data_list<span class="sc">$</span>N <span class="ot">&lt;-</span> <span class="fu">nrow</span>(Xmat) <span class="co">#n. di osservazioni train set</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>data_list<span class="sc">$</span>Ntest <span class="ot">&lt;-</span> <span class="fu">nrow</span>(Xmat_test) <span class="co">#n. di osservazioni test set</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>data_list<span class="sc">$</span>J <span class="ot">&lt;-</span> <span class="fu">ncol</span>(Xmat) <span class="co">#n. di colonne</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>data_list<span class="sc">$</span>B0 <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>, <span class="fu">ncol</span>(Xmat)) <span class="co">#vettore delle medie dei Beta a priori</span></span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Costruiamo ora il modello in STAN:</p>
<div class="cell" data-output.var="lin_mod">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> &lt;<span class="kw">lower</span> = <span class="dv">0</span>&gt; N;                    <span class="co">// numerosità campionaria</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> &lt;<span class="kw">lower</span> = <span class="dv">0</span>&gt; Ntest;  </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> &lt;<span class="kw">lower</span> = <span class="dv">0</span>&gt; J;                    <span class="co">// numero di covariate</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[N] y;                          <span class="co">// variabile risposta</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[N,J] X;                        <span class="co">// matrice dei predittori </span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[J,J] D0;                       <span class="co">// matrice della varianza a priori dei beta</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[J] B0;</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[Ntest,J] Xtest;</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[J] beta;                       <span class="co">// effetti fissi</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> &lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; sigma;                 <span class="co">// varianza </span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="kw">transformed parameters</span> {</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real</span> lprior;</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>  lprior = inv_gamma_lpdf(sigma | <span class="fl">0.01</span>, <span class="fl">0.01</span>);  <span class="co">// prior per sigma</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>  lprior +=  multi_normal_lpdf(beta | B0, D0*sigma); <span class="co">// prior per beta</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">target +=</span> lprior;</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">target +=</span> normal_id_glm_lpdf(y | X, <span class="dv">0</span>, beta, sigma); <span class="co">// postirior</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a><span class="kw">generated quantities</span> {</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[Ntest] prev;</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>  prev = Xtest * beta;</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Stimiamo quattro catene di 2000 iterazioni ciascuna; per ogni catena fissiamo un burn-in di 1000 iterazioni.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>lin_mod1 <span class="ot">&lt;-</span> <span class="fu">sampling</span>(lin_mod, <span class="at">data =</span> data_list, <span class="at">iter =</span> <span class="dv">2000</span>, <span class="at">chains =</span> <span class="dv">4</span>, <span class="at">cores =</span> <span class="dv">6</span>)</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Valutiamo la convergenza delle catene:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>rstan<span class="sc">::</span><span class="fu">traceplot</span>(lin_mod1, <span class="at">pars =</span> <span class="fu">names</span>(lin_mod1)[<span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>])</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BVS_files/figure-html/unnamed-chunk-15-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Le catene sembrano convergere alla medesima distribuzione.</p>
<p>Vediamo il grafico dell’Rhat (statistica di Gelman-Rubin) per ogni parametro stimato.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mcmc_rhat</span>(<span class="fu">rhat</span>(lin_mod1, <span class="at">pars =</span> <span class="fu">names</span>(lin_mod1)[<span class="dv">1</span><span class="sc">:</span><span class="dv">20</span>]))</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BVS_files/figure-html/unnamed-chunk-16-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>L’ R-hat è una statistica che consente di comprendere se le catene convergono alla medesima distribuzione. Nel caso ideale, l’R-hat dovrebbe essere circa pari a 1, indicando quindi che le catene campionano dalla medesima distribuzione sottostante. Se dovessimo avere dei valori più grandi di 1.1/1.2 allora le nostre catene non convergono, quindi è necessario aumentare il numero di iterazioni oppure apportare altre modifiche (ad esempio riparametrizzare il modello).</p>
<p>Le diagnostiche di convergenza non mostrano alcuna particolare problematica: sembra che le catene raggiungano la convergenza poichè R-hat è inferiore a 1.1.</p>
<p>Valutiamo la bontà di adattamento del modello ai dati attraverso l’analisi dei residui.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>betahat_lin1 <span class="ot">&lt;-</span> <span class="fu">summary</span>(lin_mod1)<span class="sc">$</span>summary[<span class="dv">1</span><span class="sc">:</span><span class="dv">19</span>, <span class="st">"mean"</span>]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>res_lin1 <span class="ot">&lt;-</span> tr_data<span class="sc">$</span>log_mkval <span class="sc">-</span> (<span class="fu">as.matrix</span>(data_list<span class="sc">$</span>X)<span class="sc">%*%</span> betahat_lin1)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="fu">data.frame</span>(<span class="at">res =</span> res_lin1) <span class="sc">%&gt;%</span> </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> res)) <span class="sc">+</span> </span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>(<span class="fu">aes</span>(<span class="at">y=</span><span class="fu">after_stat</span>(density)), <span class="at">bins =</span> <span class="dv">30</span>) <span class="sc">+</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"residui del modello"</span>) <span class="sc">+</span> </span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">stat_overlay_normal_density</span>(<span class="at">color =</span> <span class="st">"red"</span>, <span class="at">linetype =</span> <span class="st">"dashed"</span>)</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BVS_files/figure-html/unnamed-chunk-17-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data.frame</span>(<span class="at">res =</span> res_lin1, <span class="at">Age =</span> tr_data<span class="sc">$</span>Age) <span class="sc">%&gt;%</span> </span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">y =</span> res, <span class="at">x =</span> Age)) <span class="sc">+</span> </span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() </span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BVS_files/figure-html/unnamed-chunk-17-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data.frame</span>(<span class="at">res =</span> res_lin1, <span class="at">year =</span> <span class="fu">jitter</span>(tr_data<span class="sc">$</span>year_Q, <span class="dv">2</span>)) <span class="sc">%&gt;%</span> </span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">y =</span> res, <span class="at">x =</span> year)) <span class="sc">+</span> </span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() </span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BVS_files/figure-html/unnamed-chunk-17-3.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">qqnorm</span>(res_lin1)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">qqline</span>(res_lin1)</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BVS_files/figure-html/unnamed-chunk-17-4.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Notiamo che i residui hanno un comportamento simile alla normale, vi è una leggera deviazione sulle code della distribuzione, che potrebbe essere modellata attraverso l’utilizzo di una distribuzione a code pesanti, come ad esempio la t di student. Si osserva inoltre che non sembra esserci evidenti pattern tra i residui e i predittori.</p>
</section>
<section id="variable-selection-caso-modello-lineare-coniugato" class="level2">
<h2 class="anchored" data-anchor-id="variable-selection-caso-modello-lineare-coniugato">Variable selection: caso modello lineare coniugato</h2>
<p>Sfruttando l’algoritmo mostrato in precedenza, procediamo a fare selezione delle variabili per il modello lineare coniugato con tutte le variabili del dataset.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>name <span class="ot">&lt;-</span> <span class="fu">colnames</span>(tr_data <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span><span class="fu">all_of</span>(<span class="fu">c</span>(<span class="st">"mkval"</span>, <span class="st">"player_id"</span>, <span class="st">"name"</span>, <span class="st">"log_mkval"</span>, <span class="st">"position"</span>))))</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>formula <span class="ot">&lt;-</span> <span class="fu">paste</span>(<span class="st">"log_mkval ~"</span>, <span class="fu">paste</span>(name, <span class="at">collapse =</span> <span class="st">"+"</span>))</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>simgamma <span class="ot">&lt;-</span> <span class="fu">rs_spikeslab</span>(<span class="at">formula =</span> formula, <span class="at">R =</span> <span class="dv">5000</span>, <span class="at">burnin =</span> <span class="dv">1000</span>, </span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>                         <span class="at">data =</span> tr_data, <span class="at">verbose =</span> F, <span class="at">v =</span> <span class="dv">100</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>gamma_means <span class="ot">&lt;-</span> <span class="fu">colMeans</span>(simgamma<span class="sc">$</span>gamma)</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Nel vettore (gamma_means) si possono osservare le probabilità di inclusione delle variabili all’interno del modello.</p>
<p>Le 10 variabili con maggiore probabilità di inclusione sono:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>gamma_means[<span class="fu">order</span>(gamma_means, <span class="at">decreasing =</span> T)][<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>]</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                        year_Q 
                                             1 
        typedomestic_league_x_month_min_palyed 
                                             1 
           typedomestic_cup_x_month_min_palyed 
                                             1 
                  typeother_x_month_min_palyed 
                                             1 
       typedomestic_league_x_month_yellow_card 
                                             1 
              typedomestic_league_x_month_goal 
                                             1 
           typedomestic_league_x_month_assists 
                                             1 
  typedomestic_league_x_month_club_goal_scored 
                                             1 
     typedomestic_cup_x_month_club_goal_scored 
                                             1 
typedomestic_league_x_month_club_goal_conceded 
                                             1 </code></pre>
</div>
</div>
<p>Mentre le 10 variabili con minor probabilità di inclusione sono:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>gamma_means[<span class="fu">order</span>(gamma_means)][<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>]</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      typeinternational_cup_x_month_min_palyed 
                                       0.00000 
          typedomestic_cup_x_month_yellow_card 
                                       0.00000 
                 typeother_x_month_yellow_card 
                                       0.00000 
                   typeother_x_month_red_cards 
                                       0.00000 
            typeinternational_cup_x_month_goal 
                                       0.00000 
typeinternational_cup_x_month_club_goal_scored 
                                       0.00000 
                                          foot 
                                       0.00000 
                     typeother_x_month_assists 
                                       0.00075 
            typedomestic_cup_x_month_red_cards 
                                       0.00200 
     typeinternational_cup_x_month_yellow_card 
                                       0.00825 </code></pre>
</div>
</div>
<p>Un’alternativa alla funzione da noi implementata consiste nell’utilizzo di una funzione della libreria BoomSpikeSlab, <span class="citation" data-cites="scott2023package">Scott e Scott (<a href="#ref-scott2023package" role="doc-biblioref">2023</a>)</span>, che stima i parametri attraverso un gibbs sampling, in cui ogni indicatore di inclusione (di ogni variabile) viene campionato ad ogni passo condizionatamente a tutti gli altri indicatori. Un’importante differenza tra l’algoritmo che abbiamo scritto e la funzione <span class="math inline">\(lm.spike\)</span> del pacchetto è che <span class="math inline">\(lm.spike\)</span> specifica un indicatore <span class="math inline">\(\gamma\)</span> per ogni parametro, quindi per ogni modalità delle variabili qualitative, mentre il nostro l’algoritmo specifica un parametro <span class="math inline">\(\gamma\)</span> per ogni variabile. Di conseguenza, noi forniamo la probabilità di inclusione a livello di variabile, mentre il pacchetto la fornisce a livello di modalità delle variabili.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>model_boom <span class="ot">&lt;-</span>  <span class="fu">lm.spike</span>(formula, <span class="at">niter =</span> <span class="dv">5000</span>, <span class="at">data =</span> tr_data, <span class="at">ping =</span> <span class="dv">0</span>)</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>NOTA: niter= n° di iterazioni; ping= ogni quante iterazioni stampare a video lo stato di avanzamento</p>
<p>Confrontiamo le probabilità di inclusione stimate mediante il nostro algoritmo e quelle ottenute mediante il pacchetto BoomSpikeSlab per alcune variabili.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data.frame</span>(<span class="st">"BoomSpikeSlab"</span> <span class="ot">=</span> <span class="fu">apply</span>(model_boom<span class="sc">$</span>beta, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="dv">1</span><span class="sc">-</span><span class="fu">mean</span>(x<span class="sc">==</span><span class="dv">0</span>))[<span class="dv">2</span><span class="sc">:</span><span class="dv">35</span>] , </span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>           <span class="st">"RJMCMC"</span> <span class="ot">=</span> <span class="fu">round</span>(gamma_means[<span class="dv">1</span><span class="sc">:</span><span class="dv">34</span>], <span class="dv">4</span>))</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                 BoomSpikeSlab RJMCMC
year_Q                                                  0.9996 1.0000
typedomestic_league_x_month_min_palyed                  0.9988 1.0000
typeinternational_cup_x_month_min_palyed                0.0022 0.0000
typedomestic_cup_x_month_min_palyed                     0.8498 1.0000
typeother_x_month_min_palyed                            0.9992 1.0000
typedomestic_league_x_month_yellow_card                 0.9956 1.0000
typeinternational_cup_x_month_yellow_card               0.0000 0.0082
typedomestic_cup_x_month_yellow_card                    0.0000 0.0000
typeother_x_month_yellow_card                           0.0000 0.0000
typedomestic_league_x_month_red_cards                   0.0238 0.9782
typeinternational_cup_x_month_red_cards                 0.0016 0.0810
typedomestic_cup_x_month_red_cards                      0.0000 0.0020
typeother_x_month_red_cards                             0.0000 0.0000
typedomestic_league_x_month_goal                        0.9994 1.0000
typeinternational_cup_x_month_goal                      0.0000 0.0000
typedomestic_cup_x_month_goal                           0.0002 0.1100
typeother_x_month_goal                                  0.0000 0.0095
typedomestic_league_x_month_assists                     0.9994 1.0000
typeinternational_cup_x_month_assists                   0.0000 0.0650
typedomestic_cup_x_month_assists                        0.0000 0.0887
typeother_x_month_assists                               0.0000 0.0008
typedomestic_league_x_month_club_goal_scored            0.9992 1.0000
typeinternational_cup_x_month_club_goal_scored          0.0012 0.0000
typedomestic_cup_x_month_club_goal_scored               0.5134 1.0000
typeother_x_month_club_goal_scored                      0.3216 0.0565
typedomestic_league_x_month_club_goal_conceded          0.9974 1.0000
typeinternational_cup_x_month_club_goal_conceded        0.9986 1.0000
typedomestic_cup_x_month_club_goal_conceded             0.8516 1.0000
typeother_x_month_club_goal_conceded                    0.5710 1.0000
typedomestic_league_x_month_club_points                 0.7628 1.0000
typeinternational_cup_x_month_club_points               0.9982 1.0000
typedomestic_cup_x_month_club_points                    0.4828 0.0145
typeother_x_month_club_points                           0.6702 1.0000
typedomestic_league_x_best_club_position                0.9992 1.0000</code></pre>
</div>
</div>
<p>Si osserva che, ad eccezione di poche variabili, i due algoritmi producono risultati simili.</p>
<p>Passiamo, ora, a:<br>
- stimare un modello lineare conigato contenente i predittori con una probabilità di inclusione<br>
superiore a <span class="math inline">\(0.5\)</span>;<br>
- stimare un modello con tutte le varaibili;<br>
-confrontare i due modelli in termini di capacità predittiva.</p>
<p>A causa dell’elevato numero di predittori non possiamo fare ricorso a STAN per la stima dei modelli in quanto vi si presentano problemi di convergenza. Utilizziamo, invece, il pacchetto <span class="citation" data-cites="martin2011mcmcpack">Martin, Quinn, e Park (<a href="#ref-martin2011mcmcpack" role="doc-biblioref">2011</a>)</span> che permette di effettuare un gibbs sampling per il modello lineare con errori gaussiani: <span class="math display">\[
y_i= x_i^T\beta + \epsilon_i, \quad \epsilon_i \sim N(0, \sigma^2)\\
\beta \sim N(b_0, B_0^{-1}), \quad \sigma^{-2} \sim Ga(c_0/2, d_0/2), \quad \quad \beta \perp \sigma^{-2} \quad \text{a priori}
\]</span></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>top_prob_variable <span class="ot">&lt;-</span> <span class="fu">names</span>(gamma_means[gamma_means<span class="sc">&gt;</span><span class="fl">0.5</span>])</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>Xmat_selected <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(<span class="sc">~</span>., <span class="at">data =</span> <span class="fu">rbind.data.frame</span>(tr_data, te_data) <span class="sc">%&gt;%</span> </span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>                       dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="fu">all_of</span>(top_prob_variable)))</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>Xmat_train_sel <span class="ot">&lt;-</span> Xmat_selected[<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(tr_data), ]</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>, <span class="cf">function</span>(l) {</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">MCMCregress</span>(tr_data<span class="sc">$</span>log_mkval <span class="sc">~</span> Xmat_train_sel <span class="sc">-</span> <span class="dv">1</span>, <span class="at">mcmc =</span> <span class="dv">2000</span>, <span class="at">burnin =</span> <span class="dv">1000</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>}) <span class="sc">%&gt;%</span> <span class="fu">mcmc.list</span>() <span class="ot">-&gt;</span> model_selected</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>NOTA: verbose=0 impone di non stampare a video i progressi.</p>
<p>Per brevità non riportiamo tutte le analisi di convergenza delle catene.</p>
<p>Stimiamo anche il modello completo:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>name_disc <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"mkval"</span>, <span class="st">"player_id"</span>, <span class="st">"name"</span>, <span class="st">"log_mkval"</span>, <span class="st">"position"</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>Xmat_all <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(<span class="sc">~</span>., <span class="at">data =</span> <span class="fu">rbind.data.frame</span>(tr_data, te_data) <span class="sc">%&gt;%</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>                       dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span><span class="fu">all_of</span>(name_disc)))</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>Xmat_train_all  <span class="ot">&lt;-</span> Xmat_all[<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(tr_data), ]</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>, <span class="cf">function</span>(l) {</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">MCMCregress</span>(tr_data<span class="sc">$</span>log_mkval <span class="sc">~</span> Xmat_train_all <span class="sc">-</span> <span class="dv">1</span>, <span class="at">mcmc =</span> <span class="dv">2000</span>, <span class="at">burnin =</span> <span class="dv">1000</span>, <span class="at">verbose =</span> <span class="dv">0</span>)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>}) <span class="sc">%&gt;%</span> <span class="fu">mcmc.list</span>() <span class="ot">-&gt;</span> model_all</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Valutimo i diversi modelli in termini di capacità predittiva:</p>
<p>Le previsioni che si ottengono con il pacchetto BoomSpikeSlab mediano le previsioni che si ottengono con ogni generazione dei parametri, ad ogni generazione vengono stimati alcuni parametri a zero mentre altri diversi da zero, quindi la densità previsiva in corrispondenza di un insieme di predittori <span class="math inline">\(\textbf{x}_{i}\)</span> viene costruita utilizzando diverse dimensionalità del vettore di parametri <span class="math inline">\(\beta\)</span>.</p>
<p>Confrontiamo i diversi errori</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>err_dat <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="st">"MSE"</span> <span class="ot">=</span> <span class="fu">c</span>(err_lin_stan, err_boom_spsl, err_all, err_sel))</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(err_dat) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Variabili di interesse"</span>, <span class="st">"BoomSpikeSlab"</span>,</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>                       <span class="st">"Tutte le variabili"</span>, <span class="st">"RJMCMC"</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>err_dat</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                MSE
Variabili di interesse 5.084115e+06
BoomSpikeSlab          8.605812e-01
Tutte le variabili     8.618438e-01
RJMCMC                 8.621516e-01</code></pre>
</div>
</div>
<p>Come ci aspettavamo l’errore ottenuto mediante il modello in cui abbiamo utilizzato un numero ristretto di variabili (le più interessanti) è il più elevato. L’errore ottenuto mediante gli altri tre modelli risulta essere molto simile. Questo ci porta ad affermare che la selezione delle variabili non apporta benefici alla previsione, ma sicuramente migliora l’aspetto interpretativo, perchè ci permette di selezionare le variabili che influenzano maggiormente la risposta.</p>
<p>L’ <span class="math inline">\(R^{2}\)</span> del modello stimato con variabili selezionate mediante sthocastic search risulta essere pari a</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>res_sel_lin <span class="ot">&lt;-</span> tr_data<span class="sc">$</span>log_mkval <span class="sc">-</span> <span class="fu">rowMeans</span>(Xmat_train_sel <span class="sc">%*%</span> <span class="fu">t</span>(model_sel_sim[, <span class="sc">-</span><span class="dv">214</span>]))</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>R2 <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">var</span>(res_sel_lin) <span class="sc">/</span> <span class="fu">var</span>(tr_data<span class="sc">$</span>log_mkval)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>R2</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.6146645</code></pre>
</div>
</div>
<p>Densità del parametro dei minuti giocati in campionato e coppe</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data.frame</span>(<span class="st">"minuti"</span> <span class="ot">=</span> <span class="fu">c</span>(model_sel_sim[, <span class="dv">3</span>], model_sel_sim[, <span class="dv">5</span>]), </span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>           <span class="st">"Competizione"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"Campionato"</span>, <span class="dv">8000</span>), <span class="fu">rep</span>(<span class="st">"Coppa"</span>, <span class="dv">8000</span>))) <span class="sc">%&gt;%</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> minuti, <span class="at">y =</span> Competizione, <span class="at">fill =</span> Competizione)) <span class="sc">+</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_density_ridges</span>() <span class="sc">+</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_ridges</span>() <span class="sc">+</span> </span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>) <span class="sc">+</span> </span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Minuti giocati"</span>)</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Picking joint bandwidth of 0.00102</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BVS_files/figure-html/unnamed-chunk-28-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Vediamo che vi è un ordinamento stocastico tra le due variabili casuali, il parametro associato alla variabile minuti giocati in campionato risulta essere stocasticamente più grande.</p>
<p>L’effetto stimato dell’età sul valore del giocatore risulta essere</p>
<p>Come abbiamo visto precedentemente i dati a nostra disposizione sono longitudinali, infatti per molti giocatori disponiamo di più osservazioni nel tempo. Possiamo quindi inserire un’intercetta casuale per giocatore e stimare un modello ad effetti misti.</p>
</section>
<section id="modello-ad-effetti-misti" class="level2">
<h2 class="anchored" data-anchor-id="modello-ad-effetti-misti">Modello ad effetti misti</h2>
<p>Adattiamo un modello lineare ad effetti misti del tipo <span class="math display">\[
\begin{split}
&amp;Y|\beta_\gamma,u,\sigma^2_\epsilon,\sigma^2_u \:\:\:\: \sim \: N(X_\beta + Zu,\: \sigma^2_\epsilon I_n ) \\[1.1ex]
&amp;\text{dove}\\[1.1ex]
&amp;\beta|\sigma^2_\epsilon \:\:\:\: \sim \: N(0, \: \sigma^2_\epsilon D_0)\\[1.1ex]
%
&amp;\sigma^2_\epsilon \:\:\:\: \sim \: IG(\nu_\epsilon, \: \lambda_\epsilon)\\[1.1ex]
%
&amp;u \:\:\:\: \sim \: N_k(0,\: \sigma^2_u I_k)\\[1.1ex]
%
&amp;\sigma^2_u \:\:\:\: \sim \: IG(\nu_u, \: \lambda_u)\\[1.1ex]
%
\end{split}  
\]</span></p>
<p>Per stimare il modello utilizziamo uno schema gibbs sampling. Le full conditional sono analoghe a quelle viste per il gibbs spike and slab, ad eccezione per il fatto che fissiamo tutti i parametri gamma a 1.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># gibbs sampler</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>gibbs_random_eff <span class="ot">&lt;-</span> <span class="cf">function</span>(R, beta_init, sigma_init, u_init, Z, y, X, <span class="at">burnin =</span> R<span class="sc">/</span><span class="dv">2</span>,</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>                            ni_e, ni_u, lambda_e, lambda_u, D0, <span class="at">verbose =</span> F)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>{ <span class="co"># in sigma_init prima posizione sigma_e ed in seconda posizione sigma_u</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  p_b <span class="ot">&lt;-</span> <span class="fu">ncol</span>(X)</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  p_u <span class="ot">&lt;-</span> <span class="fu">ncol</span>(Z)</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(X)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>  par_init <span class="ot">&lt;-</span> <span class="fu">c</span>(beta_init, u_init, sigma_init)</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># matrici che conterrà le simulazioni</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>  parout <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, R<span class="sc">+</span><span class="dv">1</span>, <span class="fu">length</span>(par_init))</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(parout) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">colnames</span>(X), <span class="fu">colnames</span>(Z), <span class="st">"Sigma_e^2"</span>, <span class="st">"Sigma_u^2"</span>)</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># inserisco i parametri inizializzati</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>  parout[<span class="dv">1</span>, ] <span class="ot">&lt;-</span> par_init</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># matrici che serviranno in tutto l'algoritmo</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>  X <span class="ot">&lt;-</span> <span class="fu">Matrix</span>(X) <span class="co"># trasformo X in matrice sparsa</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>  Z <span class="ot">&lt;-</span> <span class="fu">Matrix</span>(Z) <span class="co"># trasformo Z in matrice sparsa</span></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>  XtX <span class="ot">&lt;-</span> <span class="fu">crossprod</span>(X)         <span class="co"># t(X) %*% X</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>  D_inv <span class="ot">&lt;-</span> <span class="fu">Matrix</span>(<span class="fu">solve</span>(D0))</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>  XtX_inv <span class="ot">&lt;-</span> <span class="fu">chol2inv</span>(<span class="fu">chol</span>(XtX <span class="sc">+</span> D_inv))  <span class="co"># (t(X) %*% X + D0^-1)^-1</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>  ZtZ <span class="ot">&lt;-</span> <span class="fu">crossprod</span>(Z)</span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>R)</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># genero i beta</span></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>    sigma_e <span class="ot">&lt;-</span> parout[i, <span class="fu">length</span>(par_init)<span class="sc">-</span><span class="dv">1</span>]</span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>    epsilon_u <span class="ot">&lt;-</span> y <span class="sc">-</span> Z <span class="sc">%*%</span> parout[i, (p_b<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>(p_b <span class="sc">+</span> p_u)]</span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>    parout[i<span class="sc">+</span><span class="dv">1</span>, <span class="dv">1</span><span class="sc">:</span>p_b] <span class="ot">&lt;-</span> mvnfast<span class="sc">::</span><span class="fu">rmvn</span>(<span class="dv">1</span>, <span class="at">mu =</span> XtX_inv <span class="sc">%*%</span> <span class="fu">crossprod</span>(X, epsilon_u),</span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>                                              <span class="at">sigma =</span> XtX_inv <span class="sc">*</span> sigma_e)</span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># genero gli u</span></span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a>    sigma_u <span class="ot">&lt;-</span> parout[i, <span class="fu">length</span>(par_init)]</span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">&lt;-</span> <span class="fu">Diagonal</span>(p_u) <span class="sc">*</span>  (sigma_e <span class="sc">/</span> sigma_u)</span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>    epsilon_b <span class="ot">&lt;-</span> y <span class="sc">-</span> X <span class="sc">%*%</span> <span class="fu">as.vector</span>(parout[i<span class="sc">+</span><span class="dv">1</span>, <span class="dv">1</span><span class="sc">:</span>p_b])</span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a>    ZTZ_inv <span class="ot">&lt;-</span> <span class="fu">chol2inv</span>(<span class="fu">chol</span>(ZtZ <span class="sc">+</span> B))</span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>    parout[i<span class="sc">+</span><span class="dv">1</span>, (p_b<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>(p_b<span class="sc">+</span>p_u)] <span class="ot">&lt;-</span> <span class="fu">rmvn.sparse</span>(<span class="dv">1</span>, <span class="at">mu =</span> ZTZ_inv <span class="sc">%*%</span> <span class="fu">crossprod</span>(Z, epsilon_b),</span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">CH =</span> <span class="fu">Cholesky</span>(<span class="dv">1</span><span class="sc">/</span>sigma_e <span class="sc">*</span> (ZtZ <span class="sc">+</span> B)), <span class="at">prec =</span> T)<span class="sc">@</span>x</span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># genero sigma epsilon </span></span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a>    epsilon_tot <span class="ot">&lt;-</span> epsilon_b <span class="sc">-</span> Z <span class="sc">%*%</span> parout[i<span class="sc">+</span><span class="dv">1</span>, (p_b<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>(p_b<span class="sc">+</span>p_u)]</span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a>    beta_cor <span class="ot">&lt;-</span> <span class="fu">as.vector</span>(parout[i<span class="sc">+</span><span class="dv">1</span>, <span class="dv">1</span><span class="sc">:</span>p_b])</span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a>    parout[i<span class="sc">+</span><span class="dv">1</span>, <span class="fu">length</span>(par_init)<span class="sc">-</span><span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span><span class="fu">rgamma</span>(<span class="dv">1</span>, (n<span class="sc">/</span><span class="dv">2</span> <span class="sc">+</span> ni_e <span class="sc">+</span> p_b<span class="sc">/</span><span class="dv">2</span>),</span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a>                                                <span class="fu">drop</span>(<span class="fu">crossprod</span>(epsilon_tot)<span class="sc">/</span><span class="dv">2</span> <span class="sc">+</span> </span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a>                                                   <span class="fu">quad.form</span>(D_inv, beta_cor)<span class="sc">/</span><span class="dv">2</span> <span class="sc">+</span> </span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a>                                                   lambda_e))</span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># genero sigma_u</span></span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a>    u_cor <span class="ot">&lt;-</span> parout[i<span class="sc">+</span><span class="dv">1</span>, (p_b<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>(p_b<span class="sc">+</span>p_u)]</span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a>    parout[i<span class="sc">+</span><span class="dv">1</span>, <span class="fu">length</span>(par_init)] <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span><span class="fu">rgamma</span>(<span class="dv">1</span>, ni_u <span class="sc">+</span> p_u<span class="sc">/</span><span class="dv">2</span>, (<span class="fu">crossprod</span>(u_cor)<span class="sc">/</span><span class="dv">2</span> <span class="sc">+</span> lambda_u))</span>
<span id="cb39-50"><a href="#cb39-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-51"><a href="#cb39-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(verbose <span class="sc">==</span> T) <span class="fu">print</span>(i)</span>
<span id="cb39-52"><a href="#cb39-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-53"><a href="#cb39-53" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb39-54"><a href="#cb39-54" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(coda<span class="sc">::</span><span class="fu">mcmc</span>(parout[<span class="sc">-</span>(<span class="dv">1</span><span class="sc">:</span>burnin), ]))</span>
<span id="cb39-55"><a href="#cb39-55" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Stimiamo un modello ad effetti casuali inizialmente considerando tutte le variabili a disposizione. Utiliziamo 4 catene per poter poi valutare la convergenza alla distribuzione target.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>X_all <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(<span class="fu">as.formula</span>(formula), <span class="at">data =</span> <span class="fu">rbind.data.frame</span>(tr_data, te_data))</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>X_train <span class="ot">&lt;-</span> X_all[<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(tr_data), ]</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> tr_data <span class="sc">%&gt;%</span> <span class="fu">count</span>(player_id)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>I <span class="ot">&lt;-</span> <span class="fu">sapply</span>(N<span class="sc">$</span>n, <span class="cf">function</span>(x) <span class="fu">rep</span>(<span class="dv">1</span>, x))</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>Z <span class="ot">&lt;-</span> <span class="fu">bdiag</span>(I)</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(Z) <span class="ot">&lt;-</span> N<span class="sc">$</span>player_id</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="co"># inizializzazione dei parametri</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>lmodel <span class="ot">&lt;-</span> <span class="fu">lm</span>(tr_data<span class="sc">$</span>log_mkval <span class="sc">~</span> <span class="sc">-</span><span class="dv">1</span> <span class="sc">+</span> X_train)</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1234</span>)</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>beta_init <span class="ot">&lt;-</span> mvnfast<span class="sc">::</span><span class="fu">rmvn</span>(<span class="dv">4</span>, <span class="fu">coef</span>(lmodel), <span class="dv">2</span><span class="sc">*</span><span class="fu">diag</span>(<span class="fu">summary</span>(lmodel)<span class="sc">$</span>coefficients[, <span class="st">"Std. Error"</span>]<span class="sc">**</span><span class="dv">2</span>))</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">4321</span>)</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>sigma_init <span class="ot">&lt;-</span> mvnfast<span class="sc">::</span><span class="fu">rmvn</span>(<span class="dv">4</span>, <span class="fu">c</span>(<span class="fu">summary</span>(lmodel)<span class="sc">$</span>sigma<span class="sc">**</span><span class="dv">2</span>, <span class="dv">1</span>), <span class="fu">diag</span>(<span class="dv">2</span>)<span class="sc">*</span><span class="fl">0.5</span>)</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>u_init <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="dv">4</span>, <span class="fu">ncol</span>(Z))</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>mix_lin_mod <span class="ot">&lt;-</span> <span class="fu">mcmc.list</span>(<span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>, <span class="cf">function</span>(i) </span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gibbs_random_eff</span>(<span class="dv">2</span> <span class="sc">*</span> <span class="dv">10</span><span class="sc">**</span><span class="dv">3</span>, beta_init[i, ], sigma_init[i, ], u_init[i, ], <span class="at">Z=</span>Z,</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>                                <span class="at">y =</span> tr_data<span class="sc">$</span>log_mkval, <span class="at">X =</span> X_train, <span class="at">ni_e=</span><span class="fl">0.1</span>, <span class="at">ni_u=</span><span class="fl">0.1</span>,</span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>                                <span class="at">lambda_e=</span><span class="fl">0.1</span>, <span class="at">lambda_u=</span><span class="fl">0.1</span>, <span class="at">D0 =</span> <span class="dv">100</span><span class="sc">*</span><span class="fu">diag</span>(<span class="fu">ncol</span>(X_train)),</span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>                                <span class="at">verbose =</span> F)))</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Per brevità non riportiamo tutte le diagnostiche di convergenza. Vediamo il traceplot di alcuni parametri (tra cui le varianze <span class="math inline">\(\sigma_{\epsilon}\)</span> e <span class="math inline">\(\sigma_{u}\)</span>)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">4</span>))</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>coda<span class="sc">::</span><span class="fu">traceplot</span>(mix_lin_mod[, <span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">14</span>, <span class="fu">ncol</span>(mix_lin_mod[[<span class="dv">1</span>]])<span class="sc">-</span><span class="dv">1</span>, <span class="fu">ncol</span>(mix_lin_mod[[<span class="dv">1</span>]]))])</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BVS_files/figure-html/unnamed-chunk-32-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Possiamo guardare la stima della distribuzione della varianza dell’effetto casuale</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>mix_lin_mod_sim <span class="ot">&lt;-</span> <span class="fu">do.call</span>(rbind, <span class="fu">lapply</span>(mix_lin_mod, <span class="cf">function</span>(l) l))</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data.frame</span>(<span class="st">"sigma2_u"</span> <span class="ot">=</span> mix_lin_mod_sim[, <span class="fu">ncol</span>(mix_lin_mod_sim)<span class="sc">-</span><span class="dv">1</span>]) <span class="sc">%&gt;%</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> sigma2_u)) <span class="sc">+</span> </span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_density</span>()<span class="sc">+</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Distribuzione della varianza di u"</span>) <span class="sc">+</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="fu">expression</span>(sigma<span class="sc">^</span><span class="dv">2</span>))</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BVS_files/figure-html/unnamed-chunk-33-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Osservando una stima della distribuzione possiamo affermare che il parametro di <span class="math inline">\(\sigma^{2}_{u}\)</span> sia diverso da zero, risulta quindi ragionevole inserire l’intercetta casuale nel modello.</p>
<p>L’<span class="math inline">\(R^{2}\)</span> del modello risulta essere pri a:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="sc">-</span> <span class="fu">var</span>(res_mixed_all)<span class="sc">/</span><span class="fu">var</span>(tr_data<span class="sc">$</span>log_mkval)</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.8854975</code></pre>
</div>
</div>
<p>Con un solo parametro in più, rispetto al modello ad effetti fissi, riusciamo a migliorare notevolmente l’indice <span class="math inline">\(R^{2}\)</span>.</p>
</section>
<section id="variable-selection-modello-ad-effetti-misti" class="level2">
<h2 class="anchored" data-anchor-id="variable-selection-modello-ad-effetti-misti">Variable selection: modello ad effetti misti</h2>
<p>Fino ad ora abbiamo affrontato il problema della selezione del modello nell’ambito del modello lineare con effetti fissi. Potremmo essere interessati a fare selezione del modello per modelli ad effetti misti. Consideriamo il modello lineare con un’intercetta casuale, in cui ci condizioniamo alla presenza dell’effetto casuale e facciamo selezione delle variabili mediante distribuzione a priori dirac spike and slab per i parametri fissi del modello.</p>
<p>Per stimare il modello specificato (precedentemente) abbiamo implementato uno schema ibrido gibbs-metropolis, in cui utilizziamo le distribuzioni condizionate note per generare tutti i parametri ad eccezione dei parametri <span class="math inline">\(\gamma\)</span> che richiedono un passo di metropolis.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># inizializzazione dei parametri</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>p_beta <span class="ot">&lt;-</span> tr_data <span class="sc">%&gt;%</span> </span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span><span class="fu">all_of</span>(<span class="fu">c</span>(<span class="st">"player_id"</span>, <span class="st">"position"</span>,<span class="st">"name"</span>, <span class="st">"log_mkval"</span>, <span class="st">"mkval"</span>))) <span class="sc">%&gt;%</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  ncol</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>gamma_init <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(p_beta, <span class="at">size =</span> <span class="dv">1</span>, <span class="at">p =</span> <span class="fl">0.5</span>)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>beta_init <span class="ot">&lt;-</span> beta_init[<span class="dv">1</span>, ]</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>sigma_init <span class="ot">&lt;-</span> sigma_init[<span class="dv">1</span>, ]</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>u_init <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>, <span class="fu">ncol</span>(Z))</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>gibbs_spike_samp <span class="ot">&lt;-</span> <span class="fu">gibbs_spikeslab</span>(<span class="dv">4</span> <span class="sc">*</span> <span class="dv">10</span><span class="sc">**</span><span class="dv">3</span>, beta_init, sigma_init, u_init, gamma_init, </span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>                      tr_data <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span><span class="fu">all_of</span>(<span class="fu">c</span>(<span class="st">"player_id"</span>, <span class="st">"position"</span>,<span class="st">"name"</span>, <span class="st">"mkval"</span>))), </span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>                      <span class="at">Z=</span>Z, <span class="at">response =</span> <span class="st">"log_mkval"</span>, <span class="at">theta=</span><span class="fl">0.5</span>, <span class="at">ni_e=</span><span class="fl">0.01</span>, <span class="at">ni_u=</span><span class="fl">0.01</span>, </span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>                      <span class="at">lambda_e=</span><span class="fl">0.01</span>, <span class="at">lambda_u=</span><span class="fl">0.01</span>, <span class="at">v=</span><span class="dv">100</span>, <span class="at">verbose =</span> F)</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>mix_mod_sel <span class="ot">&lt;-</span> <span class="fu">colMeans</span>(gibbs_spike_samp<span class="sc">$</span>gamma[<span class="sc">-</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">1000</span>), ]) <span class="co"># tolgo il burnin = 1000</span></span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Un breve confronto delle probabilità stimate da quest’ultimo algoritmo ed i due precedenti</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data.frame</span>(<span class="st">"BoomSpikeSlab"</span> <span class="ot">=</span> <span class="fu">apply</span>(model_boom<span class="sc">$</span>beta, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="dv">1</span><span class="sc">-</span><span class="fu">mean</span>(x<span class="sc">==</span><span class="dv">0</span>))[<span class="dv">2</span><span class="sc">:</span><span class="dv">35</span>] , </span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>           <span class="st">"RJMCMC"</span> <span class="ot">=</span> <span class="fu">round</span>(gamma_means[<span class="dv">1</span><span class="sc">:</span><span class="dv">34</span>], <span class="dv">4</span>), </span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>           <span class="st">"mixedmodel"</span> <span class="ot">=</span>mix_mod_sel[<span class="dv">1</span><span class="sc">:</span><span class="dv">34</span>])</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                 BoomSpikeSlab RJMCMC
year_Q                                                  0.9996 1.0000
typedomestic_league_x_month_min_palyed                  0.9988 1.0000
typeinternational_cup_x_month_min_palyed                0.0022 0.0000
typedomestic_cup_x_month_min_palyed                     0.8498 1.0000
typeother_x_month_min_palyed                            0.9992 1.0000
typedomestic_league_x_month_yellow_card                 0.9956 1.0000
typeinternational_cup_x_month_yellow_card               0.0000 0.0082
typedomestic_cup_x_month_yellow_card                    0.0000 0.0000
typeother_x_month_yellow_card                           0.0000 0.0000
typedomestic_league_x_month_red_cards                   0.0238 0.9782
typeinternational_cup_x_month_red_cards                 0.0016 0.0810
typedomestic_cup_x_month_red_cards                      0.0000 0.0020
typeother_x_month_red_cards                             0.0000 0.0000
typedomestic_league_x_month_goal                        0.9994 1.0000
typeinternational_cup_x_month_goal                      0.0000 0.0000
typedomestic_cup_x_month_goal                           0.0002 0.1100
typeother_x_month_goal                                  0.0000 0.0095
typedomestic_league_x_month_assists                     0.9994 1.0000
typeinternational_cup_x_month_assists                   0.0000 0.0650
typedomestic_cup_x_month_assists                        0.0000 0.0887
typeother_x_month_assists                               0.0000 0.0008
typedomestic_league_x_month_club_goal_scored            0.9992 1.0000
typeinternational_cup_x_month_club_goal_scored          0.0012 0.0000
typedomestic_cup_x_month_club_goal_scored               0.5134 1.0000
typeother_x_month_club_goal_scored                      0.3216 0.0565
typedomestic_league_x_month_club_goal_conceded          0.9974 1.0000
typeinternational_cup_x_month_club_goal_conceded        0.9986 1.0000
typedomestic_cup_x_month_club_goal_conceded             0.8516 1.0000
typeother_x_month_club_goal_conceded                    0.5710 1.0000
typedomestic_league_x_month_club_points                 0.7628 1.0000
typeinternational_cup_x_month_club_points               0.9982 1.0000
typedomestic_cup_x_month_club_points                    0.4828 0.0145
typeother_x_month_club_points                           0.6702 1.0000
typedomestic_league_x_best_club_position                0.9992 1.0000
                                                 mixedmodel
year_Q                                           0.89103632
typedomestic_league_x_month_min_palyed           0.72542486
typeinternational_cup_x_month_min_palyed         0.21026325
typedomestic_cup_x_month_min_palyed              0.35654782
typeother_x_month_min_palyed                     0.44451849
typedomestic_league_x_month_yellow_card          0.29590137
typeinternational_cup_x_month_yellow_card        0.15361546
typedomestic_cup_x_month_yellow_card             0.02699100
typeother_x_month_yellow_card                    0.00000000
typedomestic_league_x_month_red_cards            0.08197268
typeinternational_cup_x_month_red_cards          0.00000000
typedomestic_cup_x_month_red_cards               0.00000000
typeother_x_month_red_cards                      0.00000000
typedomestic_league_x_month_goal                 0.99166944
typeinternational_cup_x_month_goal               0.76207931
typedomestic_cup_x_month_goal                    0.69910030
typeother_x_month_goal                           0.50916361
typedomestic_league_x_month_assists              0.77774075
typeinternational_cup_x_month_assists            0.36421193
typedomestic_cup_x_month_assists                 0.10463179
typeother_x_month_assists                        0.26957681
typedomestic_league_x_month_club_goal_scored     0.80973009
typeinternational_cup_x_month_club_goal_scored   0.37754082
typedomestic_cup_x_month_club_goal_scored        0.16061313
typeother_x_month_club_goal_scored               0.17127624
typedomestic_league_x_month_club_goal_conceded   0.80073309
typeinternational_cup_x_month_club_goal_conceded 0.52715761
typedomestic_cup_x_month_club_goal_conceded      0.09430190
typeother_x_month_club_goal_conceded             0.12462512
typedomestic_league_x_month_club_points          0.46251250
typeinternational_cup_x_month_club_points        0.50749750
typedomestic_cup_x_month_club_points             0.37754082
typeother_x_month_club_points                    0.27157614
typedomestic_league_x_best_club_position         0.88303899</code></pre>
</div>
</div>
<p>Utilizzando il gibbs scritto precedentemente adattiamo un modello con tutte le covariate con probabilità di inclusione maggiore di 0.5.</p>
<p>Le variabili che includiamo nel modello sono</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>sel_var_mix <span class="ot">&lt;-</span> <span class="fu">names</span>(mix_mod_sel)[mix_mod_sel<span class="sc">&gt;</span><span class="fl">0.5</span>]</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>sel_var_mix</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "year_Q"                                          
 [2] "typedomestic_league_x_month_min_palyed"          
 [3] "typedomestic_league_x_month_goal"                
 [4] "typeinternational_cup_x_month_goal"              
 [5] "typedomestic_cup_x_month_goal"                   
 [6] "typeother_x_month_goal"                          
 [7] "typedomestic_league_x_month_assists"             
 [8] "typedomestic_league_x_month_club_goal_scored"    
 [9] "typedomestic_league_x_month_club_goal_conceded"  
[10] "typeinternational_cup_x_month_club_goal_conceded"
[11] "typeinternational_cup_x_month_club_points"       
[12] "typedomestic_league_x_best_club_position"        
[13] "Age"                                             
[14] "sub_position"                                    
[15] "foot"                                            
[16] "player_club_domestic_competition_id"             
[17] "Age2"                                            </code></pre>
</div>
</div>
<p>Adattiamo il modello e valutiamo l’errore che commettiamo nel test-set</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>form_mix <span class="ot">&lt;-</span> <span class="fu">paste</span>(<span class="st">"log_mkval ~ "</span>, <span class="fu">paste</span>(sel_var_mix, <span class="at">collapse =</span> <span class="st">"+"</span>))</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>X_sel <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(<span class="fu">as.formula</span>(form_mix), <span class="at">data =</span> <span class="fu">rbind.data.frame</span>(tr_data, te_data))</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>X_train_sel <span class="ot">&lt;-</span> X_sel[<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(tr_data), ]</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="co"># inizializzazione dei parametri</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>lmodel <span class="ot">&lt;-</span> <span class="fu">lm</span>(form_mix, <span class="at">data =</span> tr_data)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1234</span>)</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>beta_init <span class="ot">&lt;-</span> mvnfast<span class="sc">::</span><span class="fu">rmvn</span>(<span class="dv">4</span>, <span class="fu">coef</span>(lmodel), <span class="dv">2</span><span class="sc">*</span><span class="fu">diag</span>(<span class="fu">summary</span>(lmodel)<span class="sc">$</span>coefficients[, <span class="st">"Std. Error"</span>]<span class="sc">**</span><span class="dv">2</span>))</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">4321</span>)</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>sigma_init <span class="ot">&lt;-</span> mvnfast<span class="sc">::</span><span class="fu">rmvn</span>(<span class="dv">4</span>, <span class="fu">c</span>(<span class="fu">summary</span>(lmodel)<span class="sc">$</span>sigma<span class="sc">**</span><span class="dv">2</span>, <span class="dv">1</span>), <span class="fu">diag</span>(<span class="dv">2</span>)<span class="sc">*</span><span class="fl">0.5</span>)</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>u_init <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="dv">4</span>, <span class="fu">ncol</span>(Z))</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>mix_lin_sel_mod <span class="ot">&lt;-</span> <span class="fu">gibbs_random_eff</span>(<span class="dv">5</span> <span class="sc">*</span> <span class="dv">10</span><span class="sc">**</span><span class="dv">3</span>, beta_init[<span class="dv">1</span>, ], sigma_init[<span class="dv">1</span>, ], </span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>                                    u_init[<span class="dv">1</span>, ], <span class="at">Z=</span>Z, <span class="at">y =</span> tr_data<span class="sc">$</span>log_mkval, </span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">X =</span> X_train_sel, <span class="at">ni_e=</span><span class="fl">0.1</span>, <span class="at">ni_u=</span><span class="fl">0.1</span>,<span class="at">lambda_e=</span><span class="fl">0.1</span>,</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">lambda_u=</span><span class="fl">0.1</span>, <span class="at">D0 =</span> <span class="dv">100</span><span class="sc">*</span><span class="fu">diag</span>(<span class="fu">ncol</span>(X_train_sel)), <span class="at">verbose =</span> F)</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>L’errore di previsione su tale modello risulta essere pari a</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># matrice del modello per il test set</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>X_test_all <span class="ot">&lt;-</span> X_all[(<span class="fu">nrow</span>(tr_data)<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span><span class="fu">nrow</span>(X_all), ]</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>X_test_sel <span class="ot">&lt;-</span> X_sel[(<span class="fu">nrow</span>(tr_data)<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span><span class="fu">nrow</span>(X_all), ]</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="co"># giocatori nel test presenti anche nel train</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>player_tt <span class="ot">&lt;-</span> te_data<span class="sc">$</span>player_id <span class="sc">%in%</span> <span class="fu">colnames</span>(Z)</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="co"># costruzione delle stime </span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>yhat_mixed_sel_test <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="fu">nrow</span>(X_test_sel), <span class="fu">nrow</span>(mix_lin_sel_mod))</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>u_est <span class="ot">&lt;-</span> mix_lin_sel_mod[, (<span class="fu">ncol</span>(X_test_sel)<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>(<span class="fu">ncol</span>(X_test_sel)<span class="sc">+</span><span class="fu">ncol</span>(Z))]</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(te_data))</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(player_tt[i])</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    u_pos <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="fu">colnames</span>(Z) <span class="sc">%in%</span> te_data<span class="sc">$</span>player_id[i])</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    yhat <span class="ot">&lt;-</span> X_test_sel[i, ] <span class="sc">%*%</span> <span class="fu">t</span>(mix_lin_sel_mod[, <span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(X_test_sel)]) <span class="sc">+</span> u_est[, u_pos]</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> yhat <span class="ot">&lt;-</span>  X_test_sel[i, ] <span class="sc">%*%</span> <span class="fu">t</span>(mix_lin_sel_mod[, <span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(X_test_sel)])</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>  yhat_mixed_sel_test[i, ] <span class="ot">&lt;-</span> yhat</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a><span class="co"># errore di previsione</span></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>y_hat <span class="ot">&lt;-</span> <span class="fu">rowMeans</span>(yhat_mixed_sel_test)</span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>err_mix_sel <span class="ot">&lt;-</span> <span class="fu">mean</span>((te_data<span class="sc">$</span>log_mkval <span class="sc">-</span> y_hat)<span class="sc">**</span><span class="dv">2</span>)</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>L’errore che otteniamo utilizzando tutte le covariate risulta essere pari a</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co"># matrice del modello per il test set</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>X_test_all <span class="ot">&lt;-</span> X_all[(<span class="fu">nrow</span>(tr_data)<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span><span class="fu">nrow</span>(X_all), ]</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="co"># costruzione delle stime </span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>yhat_mixed_test <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="fu">nrow</span>(X_test_sel), <span class="fu">nrow</span>(mix_lin_mod_sim))</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>u_est <span class="ot">&lt;-</span> mix_lin_mod_sim[, (<span class="fu">ncol</span>(X_test_all)<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>(<span class="fu">ncol</span>(X_test_all)<span class="sc">+</span><span class="fu">ncol</span>(Z))]</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(te_data))</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(player_tt[i])</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>  {</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    u_pos <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="fu">colnames</span>(Z) <span class="sc">%in%</span> te_data<span class="sc">$</span>player_id[i])</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>    yhat <span class="ot">&lt;-</span> X_test_all[i, ] <span class="sc">%*%</span> <span class="fu">t</span>(mix_lin_mod_sim[, <span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(X_test_all)]) <span class="sc">+</span> u_est[, u_pos]</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> yhat <span class="ot">&lt;-</span>  X_test_all[i, ] <span class="sc">%*%</span> <span class="fu">t</span>(mix_lin_mod_sim[, <span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(X_test_all)])</span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>  yhat_mixed_test[i, ] <span class="ot">&lt;-</span> yhat</span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a><span class="co"># errore di previsione</span></span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a>y_hat_all <span class="ot">&lt;-</span> <span class="fu">rowMeans</span>(yhat_mixed_test)</span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a>err_mix_all <span class="ot">&lt;-</span> <span class="fu">mean</span>((te_data<span class="sc">$</span>log_mkval <span class="sc">-</span> y_hat_all)<span class="sc">**</span><span class="dv">2</span>)</span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Osserviamo che l’errore che si commette sul test set mediante il modello con tutte le covariate a disposizione risulta essere leggermente inferiore. Tuttavia il modello selezionato dalla procedura spike and slab riduce notevolmente il numero di covariate utilizzate e migliora fortemente l’interpretabilità del modello. La differenza di errore commesso dai due modelli risulta essere trascurabile. Osserviamo infine che il modello ad effetti misti porta ad un errore di previsione notevolmente inferiore rispetto al modello ad effetti fissi.</p>
<p>Confrontiamo alcune probabilità di inclusione delle covariate stimate dai tre metodi visti</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data.frame</span>(<span class="st">"BoomSpikeSlab"</span> <span class="ot">=</span> <span class="fu">apply</span>(model_boom<span class="sc">$</span>beta, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="dv">1</span><span class="sc">-</span><span class="fu">mean</span>(x<span class="sc">==</span><span class="dv">0</span>))[<span class="dv">2</span><span class="sc">:</span><span class="dv">35</span>] , </span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>           <span class="st">"RJMCMC"</span> <span class="ot">=</span> <span class="fu">round</span>(gamma_means[<span class="dv">1</span><span class="sc">:</span><span class="dv">34</span>], <span class="dv">4</span>),</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>           <span class="st">"Gibbs_LMM"</span> <span class="ot">=</span> <span class="fu">round</span>(mix_mod_sel[<span class="dv">1</span><span class="sc">:</span><span class="dv">34</span>], <span class="dv">4</span>)) </span></code><button title="Copia negli appunti" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                 BoomSpikeSlab RJMCMC Gibbs_LMM
year_Q                                                  0.9996 1.0000    0.8910
typedomestic_league_x_month_min_palyed                  0.9988 1.0000    0.7254
typeinternational_cup_x_month_min_palyed                0.0022 0.0000    0.2103
typedomestic_cup_x_month_min_palyed                     0.8498 1.0000    0.3565
typeother_x_month_min_palyed                            0.9992 1.0000    0.4445
typedomestic_league_x_month_yellow_card                 0.9956 1.0000    0.2959
typeinternational_cup_x_month_yellow_card               0.0000 0.0082    0.1536
typedomestic_cup_x_month_yellow_card                    0.0000 0.0000    0.0270
typeother_x_month_yellow_card                           0.0000 0.0000    0.0000
typedomestic_league_x_month_red_cards                   0.0238 0.9782    0.0820
typeinternational_cup_x_month_red_cards                 0.0016 0.0810    0.0000
typedomestic_cup_x_month_red_cards                      0.0000 0.0020    0.0000
typeother_x_month_red_cards                             0.0000 0.0000    0.0000
typedomestic_league_x_month_goal                        0.9994 1.0000    0.9917
typeinternational_cup_x_month_goal                      0.0000 0.0000    0.7621
typedomestic_cup_x_month_goal                           0.0002 0.1100    0.6991
typeother_x_month_goal                                  0.0000 0.0095    0.5092
typedomestic_league_x_month_assists                     0.9994 1.0000    0.7777
typeinternational_cup_x_month_assists                   0.0000 0.0650    0.3642
typedomestic_cup_x_month_assists                        0.0000 0.0887    0.1046
typeother_x_month_assists                               0.0000 0.0008    0.2696
typedomestic_league_x_month_club_goal_scored            0.9992 1.0000    0.8097
typeinternational_cup_x_month_club_goal_scored          0.0012 0.0000    0.3775
typedomestic_cup_x_month_club_goal_scored               0.5134 1.0000    0.1606
typeother_x_month_club_goal_scored                      0.3216 0.0565    0.1713
typedomestic_league_x_month_club_goal_conceded          0.9974 1.0000    0.8007
typeinternational_cup_x_month_club_goal_conceded        0.9986 1.0000    0.5272
typedomestic_cup_x_month_club_goal_conceded             0.8516 1.0000    0.0943
typeother_x_month_club_goal_conceded                    0.5710 1.0000    0.1246
typedomestic_league_x_month_club_points                 0.7628 1.0000    0.4625
typeinternational_cup_x_month_club_points               0.9982 1.0000    0.5075
typedomestic_cup_x_month_club_points                    0.4828 0.0145    0.3775
typeother_x_month_club_points                           0.6702 1.0000    0.2716
typedomestic_league_x_best_club_position                0.9992 1.0000    0.8830</code></pre>
</div>
</div>
<p>Possiamo osservare che la selezione nel modello LMM produce probabilità di inclusione leggermente differenti rispetto agli altri due metodi visti. In particolare si osserva un risultato molto coerente con le conoscenze che abbiamo sulle valutazioni dei giocatori, nella selezione nel modello LMM viene stimata una probabilità di inclusione per la variabile “minuti giocati nelle coppe internazionali” più alta rispetto agli altri due metodi. Ancora più sorprendente è il risultato legato alla probabilità di inclusione della variabile “goal segnati nelle coppe internazionali”, in cui i due metodi per modelli ad effetti fissi stimano una probabilità di inclusione pari a 0.0004 e 0.002, mentre l’algoritmo per la selezione nel modello LMM stima una probabilità di inclusione pari a 0.6231. Tale covariata non presenta molta variabilità tra i giocatori, in quanto la maggior parte di essi non segna nelle coppe internazionali, non è quindi sorprendente che i due algoritmi di selezione per il modello ad effetti fissi stimino una bassa probabilità di inclusione di tale variabile, è piuttosto sorprendente che l’algoritmo di selezione per il modello LMM riesca a stimare una probabilità di inclusione parecchio alta.</p>
</section>
</section>
<section id="bayesian-model-selection-for-generalized-linear-mixed-models" class="level1">
<h1>Bayesian model selection for generalized linear mixed models</h1>
<p>Terminiamo questa nostra presentazione mostrando un nuovo approccio alla Bayesian model selection, introdotto da <span class="citation" data-cites="xu2023bayesian">Xu et al. (<a href="#ref-xu2023bayesian" role="doc-biblioref">2023</a>)</span>.</p>
<p>I Generalized linear mixed models (GLMM) sono ampiamente utilizzati per modellare dati di natura non Gaussiana con osservazioni dipendenti. Nonostante le procedure di stima Bayesiane per i GLMM siano utlizzate, ci sono pochi paper che parlano della Bayesian model selection per i GLMM. Attualmente, molti articoli utilizzano il deviance information criterion (DIC) (<span class="citation" data-cites="spiegelhalter2002bayesian">Spiegelhalter et al. (<a href="#ref-spiegelhalter2002bayesian" role="doc-biblioref">2002</a>)</span>) per effettuare la Bayesian model selection per i GLMM:</p>
<p><span class="math display">\[
\text{DIC} = D(\overline{\theta}) + 2p_D
\]</span> dove<br>
- <span class="math inline">\(D(\theta)= -2log p(y | \theta)\)</span> è la devianza, che misura la qualità dell’adattamento del modello ai dati: minore è la devianza, migliore è l’adattamento;<br>
-<span class="math inline">\(\overline{D(\theta)} = \mathbb{E}_{\theta|y}[D(\theta)]\)</span> è la media della devianza rispetto alla distribuzione a posteriori di <span class="math inline">\(\theta\)</span>;<br>
- <span class="math inline">\(p_D\)</span> è la complessità effettiva del modello (n° di parametri). Un modello con un DIC più basso è preferibile poichè indica un miglior equilibrio tra adattamento ai dati e complessità del modello.</p>
<p>Il problama del DIC è che non fa bene la selezione delle variabili nel caso in cui gli effetti casuali abbiano varianze grandi. Quindi, per ottenere dei risultati migliori, è stato sviluppato un nuovo Bayesian model selection approach per la selezione simultanea delle covariate e degli effetti casuali per i GLMM. Come sappiamo, fare inferenza sui GLMM è difficile perchè la funzione di verosimiglianza integrata non è disponibile in forma chiusa. Per risolvere il problema dell’integrazione degli effetti casuali, approssimiamo la funzione di verosimiglianza integrata utilizzando un approccio di pseudo-verosimiglianza che porta a una Gaussian likelihood approximation. Poi, assegniamo una flat prior al vettore dei coef di regressione e una aproximate reference prior per le componenti di varianza. In più, si considera anche il caso di una half-Cauchy prior per le radici quadrate delle componenti di varianza. Poichè la prior del vettore dei coef di regressione è impropria, è stato sviluppato un fractional Bayesian factor (FBF) approach (O’Hagan, 1995). L’approccio per la model selection è completamente automatico, quindi si evita l’inconveniente della specificazione soggettiva degli iperparametri e rende il metodo più accessibile. I due metodi per la selezione proposti prendono il nome di: - the approximate reference method (ARM); - the half-Cauchy method (HCM).</p>
<p>NOTA: l’idea alla base delle reference prior è quella di formalizzare esattamente quello he si intende per a priori non informative: è una funzione che massimizza una qualche misura di distanza o divergenza (es. Kullback-Leibler) tra la posterior e la prior. Massimizzando la divergenza, si consente ai dati di avere il massimo effetto sulle stime a posteriori. Il problema delle reference prior esatte è che possono essere difficili da ottenere, quindi, spesso, si ricorre a loro approssimazioni che mantengono le proprietà desiderate di minima informatività.</p>
<p>NOTA: la half-Cauchy prior è utile nel caso di parametri non negativi che possono assumere valori anche molto grandi.</p>
<section id="modello-di-partenza" class="level2">
<h2 class="anchored" data-anchor-id="modello-di-partenza">Modello di partenza</h2>
<p>Si consideri: - il vettore della risposta <span class="math inline">\(y=(y_1, y_2, ...., y_n)^T\)</span>; - la matrice <span class="math inline">\(X\)</span>, di dimensioni <span class="math inline">\(nxp\)</span>, dei predittori e <span class="math inline">\(\beta\)</span> il corrispettivo vettore <span class="math inline">\(p\)</span>-dimensionale di effetti fissi; - una matrice <span class="math inline">\(Z_j\)</span>, di dimensioni <span class="math inline">\(nxq_j\)</span> e il corrispettivo vettore <span class="math inline">\(\alpha_j\)</span>, di dimensione <span class="math inline">\(q_j\)</span>, di effetti casuali, per <span class="math inline">\(j=1,...,Q\)</span>; - le osservazioni <span class="math inline">\(y_1,..., Y_n\)</span> sono indipendenti con densità appartenente alla famiglia esponenziale. Ciascuna osservazione <span class="math inline">\(y_i\)</span> ha media <span class="math inline">\(mu_i\)</span> e varianza <span class="math inline">\(\nu_i\)</span>; - ciascun <span class="math inline">\(\alpha_j\)</span> ha una distribuzione normale multivariata con vettore delle medie 0 e matrice di covarianza <span class="math inline">\(\tau_j\Sigma_j\)</span>, con <span class="math inline">\(\tau_j\)</span> parametro ignoto e <span class="math inline">\(\Sigma_j\)</span> matrice nota simmetrica e semi-definita positiva;</p>
</section>
<section id="pseudo-likelihood-function" class="level2">
<h2 class="anchored" data-anchor-id="pseudo-likelihood-function">Pseudo Likelihood function</h2>
<p>Un passo fondamentale nella Bayesian model selection è integrare via gli effetti casuali dalla funzione di verosimiglianza. Tuttavia, mentre per gli LMM gli effetti casuali possono essere integrati analiticamente , per i GLMM questo non è possibile.<br>
Per risolvere questo problema, qui utilizziamo un approccio alla pseudo-verosimiglianza che approssima un GLMM per dati non-Gaussiani calcolando osservazioni aggiustate che vengono modellate utilizzando un LMM gaussiano approssimato. Consideriamo che <span class="math inline">\(\alpha\)</span> rappresenti tutti gli effetti casuali e che <span class="math inline">\(\tau\)</span> rappresenti tutte le componenti di varianza. Allora, la funzione di verosimiglianza con l’integrale (non risolvibile) sugli effetti casuali è: <span class="math display">\[
L(\beta, \tau| y) = \int p(y|\alpha, \beta)p(\alpha|\tau) d\alpha
\]</span> Il metodo qui proposto approssima questo integrale con un Gaussian LMM attraverso un approccio ala pseudo-verosimiglianza. Poi, per un modello LMM il corrispondente integrale puù essere risolto analiticamente.</p>
<p>##Cenni al pseudo-likelihood approach L’approccio alla pseudo-verosimiglianza è una procedura iterativa che inizia scrivendo il modello come <span class="math inline">\(y= \mu + \epsilon\)</span>, con <span class="math inline">\(\mu=(\mu_1,...,\mu_n)^T\)</span> e <span class="math inline">\(\epsilon\)</span> il vettore degli errori con <span class="math inline">\(Cov(\epsilon)=V=diag(\nu_1,...,\nu_n)\)</span>. Sia <span class="math inline">\(\hat{\alpha}, \hat{\beta}, \hat{\mu}, \hat{V}\)</span> le stime correnti di <span class="math inline">\(\alpha, \beta, \mu, V\)</span>. La procedura, a grandi linee, è la seguente: - <span class="math inline">\(\hat{\beta}\)</span> si inizializza sfruttando le stime di un GLM; - si approssima <span class="math inline">\(\mu_i\)</span> con uno sviluppo di Taylor del primo ordine intorno <span class="math inline">\(\alpha=\hat{\alpha}\)</span> e <span class="math inline">\(\beta = \hat{\beta}\)</span>; - si riordinano tutti i termini in <span class="math inline">\(y= \mu + \epsilon\)</span> in modo tale che i termini che dipendono da <span class="math inline">\(y\)</span>, <span class="math inline">\(\hat{\alpha}\)</span>, <span class="math inline">\(\hat{\beta}\)</span>, <span class="math inline">\(\hat{\mu}\)</span>, appaiano sul lato sinistro dell’equazione, mentre tutto il resto va a destra; - si moltiplicano entrambi i lati per <span class="math inline">\(\hat{V}^{-1}\)</span>. Come risultato, la parte di sinistra dell’equazione avrà la seguente forma: <span class="math inline">\(y^* =\hat{V}^{-1}(y - \hat{\mu}) + X\hat{\beta} + \sum_j Z_j \hat{\alpha_j}\)</span>. <span class="math inline">\(y^*\)</span> prenderà il nome di vettore di pseudo-osservazioni o vettore delle osservazioni aggiustate. - eguagliando <span class="math inline">\(y^*\)</span> con la parte destra dell’equazione, otteniamo il seguente modello per le osservazioni aggiustate: <span class="math display">\[
y^* \approx X\beta + \sum_{j}Z_j\alpha_j + \hat{V}^{-1}\epsilon \\
\alpha_j \sim N(0, \tau_j\Sigma_j) \quad \epsilon \sim N(0, V)
\]</span> Sostituendo a <span class="math inline">\(V\)</span> la sua stima <span class="math inline">\(\hat{V}\)</span> allora <span class="math inline">\(y*\)</span> puù essere modellato (approssimativamente) tramite un LMM: $ y^* N(X, _{j}_jZ_j_jZ_j^T + ^{-1})$. Quindi, adesso abbiamo a disposizione una funzione di pseudo-verosimiglianza in forma chiusa <span class="math inline">\(p(y^*|\beta,\tau)\)</span>. Per fare selezione, si utilizzarà la pseudo-verosimiglianza in modo iterativo per ottenere delle stime dei parametri, per poi calcolare osservazioni aggiustate <span class="math inline">\(y*\)</span>; poi, queste <span class="math inline">\(y*\)</span> verranno utilizzate al posto delle osservazioni originarie per fare selezione del modello. Nella pratica, il vettore delle osservazioni aggiustate verà calcolato usando il modello completo, ovvero quello con tutti i regressori e tutti gli effetti casuali.</p>
</section>
<section id="model-selection" class="level2">
<h2 class="anchored" data-anchor-id="model-selection">Model selection</h2>
<p>Si consideri lo spazio dei modelli <span class="math inline">\(M=\{M_c, c=1,..,C\}\)</span>, con <span class="math inline">\(C\)</span> il numero di possibili modelli. Assumiamo che il modello <span class="math inline">\(M_c\)</span> abbia <span class="math inline">\(K_c\)</span> regressori; che <span class="math inline">\(X_c\)</span> sia la matrice delle variabili esplicative; che <span class="math inline">\(\beta_c\)</span> sia il corrispondente vettore di coefficienti; e che <span class="math inline">\(Q_c\)</span> siano gli effetti casuali. Sia <span class="math inline">\(\tau_c=(\tau_{c,1},...,\tau_{c,Q_c})\)</span> il vettore delle componenti di varianza dei <span class="math inline">\(Q_c\)</span> effetti casuali nel modello <span class="math inline">\(M_c\)</span>. La verosimiglianza integrata basata sulle <span class="math inline">\(y^*\)</span> è: <span class="math display">\[
p(y^*|M_c)=\int \int p(y^*|\beta_c, \tau_c) \pi(\beta_c, \tau_c |M_c) d\beta_cd\tau_c
\]</span> dove <span class="math inline">\(\pi(\beta_c, \tau_c |M_c)\)</span> è la distribuzione a priori per <span class="math inline">\((\beta_c, \tau_c)\)</span> condizionatamente al modello <span class="math inline">\(M_c\)</span>. Assumendo che <span class="math inline">\(\pi(M_c)\)</span> sia la probabilità a priori del modello <span class="math inline">\(M_c\)</span>, allora, tramite l’applicazione del modello di Bayes si ottiene che la probabilità a posteriori del modello è <span class="math display">\[
P(M_c|y^*)=\frac{p(y^*|M_c)\pi(M_c)}{\sum_{r=1}^C p(y^*|M_c)\pi(M_c)} \: \alpha \: p(y^*|M_c)\pi(M_c)
\]</span></p>
</section>
<section id="prior-for-model-parameters" class="level2">
<h2 class="anchored" data-anchor-id="prior-for-model-parameters">Prior for model parameters</h2>
<p>In questo contesto si usa una flat prior per <span class="math inline">\(\beta\)</span>: <span class="math inline">\(\pi(\beta|M) \: \alpha \: 1\)</span>. Nel caso della componente di varianza <span class="math inline">\(\tau\)</span> si usano una delle seguenti: - una approximate reference prior $ _1(|M)=, $ - <span class="math inline">\(\pi_2(\tau) \: \alpha \: \tau^{\frac{-1}{2}}(\tau+1)^{-1}\)</span> (deriva dall’assumere una half-Cauchy prior per <span class="math inline">\(\sqrt \tau\)</span>).</p>
<p>Da qui emergono due varianti dell’approccio: ARM, che usa l’approximate reference prior per <span class="math inline">\(\tau\)</span>; HCM, che usa una half-Cauchy prior per <span class="math inline">\(\sqrt \tau\)</span>.</p>
</section>
<section id="priors-on-the-model-space" class="level2">
<h2 class="anchored" data-anchor-id="priors-on-the-model-space">Priors on the model space</h2>
<p>Sia <span class="math inline">\(K\)</span> il numero di covariate candidate e sia <span class="math inline">\(Q\)</span> il numero di effetti casuali candidati. Siano <span class="math inline">\(K_c\)</span> e <span class="math inline">\(Q_c\)</span>, rispettivamente, il numero di covariate e il numero di effetti casuali nel modello <span class="math inline">\(M_c\)</span>. Assumendo a priori indipendenza tra l’inclusione di effetti fissi e casuali, la probabilità a priori per il modello <span class="math inline">\(M_c\)</span> è <span class="math inline">\(P(M_c)=\frac{1}{ 2^Q(K+1)\binom{K}{K_c}}\)</span>. Questa formula deriva dal fatto che, nel caso di effetti fissi la probabilità del modello <span class="math inline">\(M_c\)</span> con <span class="math inline">\(K_c\)</span> covariate sarebbe <span class="math inline">\(\frac{1}{(K+1)\binom{K}{K_c}}\)</span>; mentre, per gli efetti casuali avremmo <span class="math inline">\(2^Q\)</span> possibilità per l’inclusione e l’esclusione degli effetti casuali. Assumendo che ciascun effetto casuale abbia una probabilità a priori di inclusione pari a 0.5, allora la probabilità per il molldeo <span class="math inline">\(M_c\)</span> con <span class="math inline">\(Q_c\)</span> effetti casuli è pari a <span class="math inline">\(1/2^Q\)</span>.</p>
<p>Dopo aver definito le priors per i parametri, possiamo ottenere la verosimiglianza integrata: i <span class="math inline">\(\beta\)</span> possono essere integrati analiticamente; mentre, per l’integrazione dei <span class="math inline">\(\tau\)</span> non si procede in maniera analitica (non c’è modo), ma si sfrutta un’approssimazione di Laplace.</p>
</section>
<section id="fractional-bayes-factors" class="level2">
<h2 class="anchored" data-anchor-id="fractional-bayes-factors">Fractional Bayes factors</h2>
<p>Per ottenere le posterior model probabilities si usano i Fractional Bayes factors (FBF), che non sono altro che una modifica dei Bayes factors per il caso di a priori improrie. Non possiamo utilizzare il Bayes factor “classico” perchè i regressori hanno una a priori impropria e questo porta a un Bayes factor definito a meno di una costante di prorporzionalità non definita e non può essere usato per confrontare modelli direttamente. Per risolvere questo problema si utilizza l’FBF: in questo modo si fa un “train” della a priori impropria in modo tale da poter calcolare un BF sensato. Per “training” della a priori improria si intende l’uso del teorema di Bayes per combinare la a priori impropria con una frazione della verosimiglianza, in modo tale da ottenere una distribuzione propria. Quest’ultima verrà poi usata per calcolare il Bayes factor. La trained prior per il modello <span class="math inline">\(M_c\)</span> si ottiene come: <span class="math display">\[
\pi^b(\beta_c,\pi_c) = \frac{p^b(y^*|\beta_c,\tau_c)\pi(\beta_c,\tau_c|M_c)}{\int p^b(y^*|\beta_c,\tau_c)\pi(\beta_c,\tau_c|M_c) d\beta_c },
\]</span> dove b è la frazione della funzione di verosimiglianza usata per fare il training della prior. La verosimiglianza integrata del modello <span class="math inline">\(M_c\)</span> viene poi calcolata come l’integrale del prodotto tra la funzione di verosimiglianza elevata alla 1-b e la trained prior: <span class="math display">\[
\begin{aligned}
q_c(b,y^*) &amp;= \int p^{1-b}(y^* \mid \beta_c, \tau_c) \pi^b(\beta_c, \tau_c) \, d\beta_c \, d\tau_c \\
&amp;= \int p^{1-b}(y^* \mid \beta_c, \tau_c) \frac{p^b(y^* \mid \beta_c, \tau_c) \pi(\beta_c, \tau_c \mid M_c)}{\int p^b(y^* \mid \beta_c, \tau_c) \pi(\beta_c, \tau_c \mid M_c) \, d\beta_c \, d\tau_c} \, d\beta_c \, d\tau_c \\
&amp;= \frac{\int p(y^* \mid \beta_c, \tau_c) \pi(\beta_c, \tau_c \mid M_c) \, d\beta_c \, d\tau_c}{\int p^b(y^* \mid \beta_c, \tau_c) \pi(\beta_c, \tau_c \mid M_c) \, d\beta_c \, d\tau_c}.
\end{aligned}
\]</span> La frazione b deve essere scelta con cautela: se è troppo piccolo allora il denominatore della formula precedente potrebbe divergere; se è troppo grande allora usiamo troppa verosimiglianza per fare training delle prior e, quindi, avremo poca informazione nella verosimiglianza integrata per aggiornare le probabilità a priori dei modelli (avremo delle probabilità a posteriori per i modelli meno distinte). Considerazioni empiriche hanno portato alla scelta di un <span class="math inline">\(b=(p+1)/n\)</span>. Quindi l’FBF del modello <span class="math inline">\(M_c\)</span> versus <span class="math inline">\(M_l\)</span> è definito come <span class="math inline">\(BF^b_{cl}=\frac{q_c(b,y^*)}{q_l(b,y^*)}\)</span>. Infine, calcoliamo la posterior probability del modello <span class="math inline">\(M_c\)</span> come: <span class="math display">\[
P^b(M_c | y) = \frac{BF^b_{cl} \times P(M_c)}{\sum_{k=1}^{C} BF^b_{cl} \times P(M_k)}.
\]</span></p>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">Referenze</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-freedman1983note" class="csl-entry" role="listitem">
Freedman, David A. 1983. <span>«A note on screening regression equations»</span>. <em>the american statistician</em> 37 (2): 152–55.
</div>
<div id="ref-jeffreys1998theory" class="csl-entry" role="listitem">
Jeffreys, Harold. 1998. <em>The theory of probability</em>. OuP Oxford.
</div>
<div id="ref-martin2011mcmcpack" class="csl-entry" role="listitem">
Martin, Andrew D, Kevin M Quinn, e Jong Hee Park. 2011. <span>«MCMCpack: Markov chain monte carlo in R»</span>.
</div>
<div id="ref-miller2002subset" class="csl-entry" role="listitem">
Miller, Alan. 2002. <em>Subset selection in regression</em>. chapman; hall/CRC.
</div>
<div id="ref-raftery1995bayesian" class="csl-entry" role="listitem">
Raftery, Adrian E. 1995. <span>«Bayesian model selection in social research»</span>. <em>Sociological methodology</em>, 111–63.
</div>
<div id="ref-scott2023package" class="csl-entry" role="listitem">
Scott, Steven L, e Maintainer Steven L Scott. 2023. <span>«Package <span>“BoomSpikeSlab”</span>»</span>.
</div>
<div id="ref-spiegelhalter2002bayesian" class="csl-entry" role="listitem">
Spiegelhalter, David J, Nicola G Best, Bradley P Carlin, e Angelika Van Der Linde. 2002. <span>«Bayesian measures of model complexity and fit»</span>. <em>Journal of the royal statistical society: Series b (statistical methodology)</em> 64 (4): 583–639.
</div>
<div id="ref-tadesse2021handbook" class="csl-entry" role="listitem">
Tadesse, Mahlet G, e Marina Vannucci. 2021. <span>«Handbook of bayesian variable selection»</span>.
</div>
<div id="ref-xu2023bayesian" class="csl-entry" role="listitem">
Xu, Shuangshuang, Marco AR Ferreira, Erica M Porter, e Christopher T Franck. 2023. <span>«Bayesian model selection for generalized linear mixed models»</span>. <em>Biometrics</em> 79 (4): 3266–78.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiato!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiato!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>